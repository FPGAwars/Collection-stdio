// Translation document for the collection
// =======================================
// This file contains the texts
// annotated for translation
//
// Instructions:
// 1. Open the PO file with Poedit
// 2. Press "Update" to update from sources

gettext('Bus');
gettext('Debug');
gettext('Device');
gettext('Others');
gettext('stdin');
gettext('stdout');
gettext('stdin-stdout-adaptor-2');
gettext('Adapter between the stdin and stdout buses. Type 2');
gettext('stdin bus splitter into data and tic signals');
gettext('The data + tic signal are added into the stdout bus)');
gettext('stdin-stdout-adaptor');
gettext('Adapter between the stdin and stdout buses');
gettext('stdout bus joiner (data + tic)');
gettext('stdin-enable');
gettext('Componente genérico');
gettext('Puerta AND');
gettext('stdin bus joiner (data + tic)');
gettext('## STDIN stream enable');
gettext('stdin-joiner');
gettext('stdin-mixer');
gettext('STDIN mixer. Combine two stdin buses into one');
gettext('Biestable de datos (Tipo D). Cuando se recibe un tic por load se captura el dato');
gettext('9 bits, 2-1 Multiplexor');
gettext('Biestable con entradas de Set y Reset síncronas, para poner y quitar notaficaciones de eventos');
gettext('**STDIN BUS 0**');
gettext('**STDIN BUS 1**');
gettext('Default input bus');
gettext('Active stdin channel');
gettext('By default, the channel 0 is selected  \nDepending on the tic received, one  \nchannel or another is selected');
gettext('The tics are delayed one cycle  \nThe fist cycle is used for selecting the  \noutput channel, the next cycle cotaints the  \nactual tic');
gettext('## STDIN-Auto-Selector\n\nIt combines automatically two input STDIN buses  \nWhenever a data is received on one of the buses,  \nit is outputed into one single STDIN bus');
gettext('stdin-spliter');
gettext('adder-data-tic');
gettext('joiner-2-data-tic');
gettext('next-in');
gettext('Convert the 1-bit next signal into a 10-bit stdout bus');
gettext('next-out');
gettext('Extract the next signal from the stdout bus');
gettext('spliter-2-data-tic');
gettext('stdout bus splitter into data and tic signals');
gettext('Memory');
gettext('Hterm-toggle');
gettext('Receptor serie asíncrono. Velocidad por defecto: 115200 baudios');
gettext('Serial transmiter for the stdout bus');
gettext('Transmisor serie');
gettext('Emitir un tic inicial al arrancar, y nunca más. Se esperan 32 tics antes de emitir el tic de inicialización');
gettext('Un bit constante a 0');
gettext('Detector de flanco de subida. Emite un tic cuando detecta un flanco ascendente');
gettext('Separador de bus de 6-bits en 1 bit y bus de 5 bits');
gettext('Contador del sistema, ascendente, de 6 bits, con enable ');
gettext('Print a constant string of 7 or less characters');
gettext('Comparador de un operando de 8 bits. Se compara si el operando es igual al parámetro');
gettext('10 bits, 2-1 Multiplexor');
gettext('Un bit constante a 1');
gettext('8-bytes memory, initilized with a string');
gettext('Máquina de contar, de 3 bits, con stop');
gettext('Biestable de almacenamiento del estado de la máquina');
gettext('Detector de flancos de subida y bajada. Emite tic por las salidas correspondientes al detecta los flancos');
gettext('Puerta NOT');
gettext('Puerta OR');
gettext('Registro de 3 bits con entrada de reset');
gettext('Comparador de dos operandos de 3 bits');
gettext('Valor genérico constante (menos 1), de 3 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Sumador de un operando de 3 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('char syntax block');
gettext('Demultiplexor de 1 bit, de 1 a 2');
gettext('Biestable de cambio (Tipo T). Cuando se recibe un tic cambia de estado');
gettext('Print a bit plus a new line');
gettext('Código ASCII del carácter LF');
gettext('Valor genérico constante, de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext(' Transmit one bit as a character. STDOUT-bus');
gettext('Multiplexor de 2 a 1 de 8 bits');
gettext('Transmit one character to the STDOUT bus');
gettext('Transmit one constant character to the STDOUT bus');
gettext('Print a constant string of 31 or less characters');
gettext('32-bytes memory, initilized with a string');
gettext('Máquina de contar, de 5 bits, con entrada de stop');
gettext('Registro de 5 bits');
gettext('5-bits adder. One operand is a constant (no carry)');
gettext('two operand 5-bits comparator');
gettext('Valor genérico constante (menos 1), de 5 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Detect if the command is valid');
gettext('Puerta OR de 3 entradas');
gettext('Input 2 chars in edit mode');
gettext('4Bytes buffer with dump');
gettext('4 bytes memory');
gettext('Máquina de contar, de 2 bits (cuenta hasta 4 ciclos)');
gettext('Registro de 2 bits con reset');
gettext('Sumador de un operando de 2 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 2 bits');
gettext('Valor genérico constante (menos 1), de 2 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Multiplexor de 2 a 1');
gettext('Multiplexor de 2 a 1 de 2 bits');
gettext('2bits up-down counter with limits. Reset');
gettext('Comparador menor que, de un operando de 2 bits');
gettext('2bits-Greather than comparator');
gettext('Codificador de 2 a 1. La salida zero se activa cuando ninguna entrada está activada');
gettext('Comparador de igualdad, de un operando de 2 bits');
gettext('Print a constant string of 3 or less characters');
gettext('4-bytes memory, initilized with a string');
gettext('Máquina de contar, de 1 bit, con entrada de Stop');
gettext('Biestable de cambio (Tipo T) con reset. Cuando se recibe un tic cambia de estado');
gettext('Filter of printable chars, in addition to enter and del');
gettext('8 bits greather or equal comparator');
gettext('8 bits less or equal than comparator');
gettext('Valor genérico constante, de 9 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('2bits-Greather or equal than comparator');
gettext('Print a constant string of 127 or less characters');
gettext('128-bytes memory, initilized with a string');
gettext('Máquina de contar, de 7 bits, con entrada de stop');
gettext('Registro de 7 bits con reset');
gettext('7-bits adder. One operand is a constant (no carry)');
gettext('two operand 7-bits comparator');
gettext('Valor genérico constante (menos 1), de 7 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Print a constant string of 63 or less characters');
gettext('64-bytes memory, initilized with a string');
gettext('Máquina de contar, de 6 bits, con entrada de stop');
gettext('Registro de 6 bits con reset');
gettext('6-bits adder. One operand is a constant (no carry)');
gettext('two operand 6-bits comparator');
gettext('Valor genérico constante (menos 1), de 6 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('**Init**');
gettext('Print the prompt');
gettext('**STDIN BUS**');
gettext('The InputLN-Charx2 component:\n\nIt waits for the user to enter the  \ncomand and pressing enter');
gettext('**STDOUT**');
gettext('### Blank command\n\nThe user has just press the  \nenter key without typibng anything');
gettext('### Toggle command\n');
gettext('State of the  \ncommands');
gettext('The command is  \nnot known');
gettext('### Unknown command\n');
gettext('A new command is  \navailable');
gettext('Dump the next  \nbyte in the next  \ncycle');
gettext('### Toggle the LED\n');
gettext('LED state');
gettext('## Toggle button OUTPUT');
gettext('Print the LED  \nstate');
gettext('Previous command  \nis finished!');
gettext('Reset the  \ncommand detectors');
gettext('After the enter is pressed  \nthe dump is started');
gettext('## STDIN serial\n\nSerial receiver for the STDIN bus\n');
gettext('**STDIN Bus**  \n* Data received (8 bits)  \n* tic (1 bit)');
gettext('## STDOUT serial\n\nSerial transmitter for the STDOUT bus\n');
gettext('**STDOUT Bus**  \n* Data to transmit (8 bits)  \n* tic (1 bit)\n* data sent (done tic, 1 bit)');
gettext('## PRINT: Transmit one character (STDOUT bus)\n\nWhen **idle**, the STDOUT bus crosses the component without modification     \n\nWhen the machine starts, the first chars outputed and the state is changed to busy  \nWhen the transmitter is done (tic received in next)  the machine is turned off');
gettext('Start tic: The transmision of  \nthe bytes is started');
gettext('Transmit the next  \ncharacter from the string');
gettext('Tic output: Execute!');
gettext('The machine has finished');
gettext('Count machine. It is counting  \nuntil the stop signal is  \nactivated');
gettext('If the character read is 0  \nwe have reached the end of  \nthe string');
gettext('Memory with the string  \nto be transmited');
gettext('**STDOUT BUS**');
gettext('Transparent mode...  \nor not');
gettext('**Reloj del sistema**');
gettext('**Estado de**  \n**la máquina**');
gettext('Máquina encendida');
gettext('Máquina apagada  \n(rst = 1)');
gettext('Tic de arranque');
gettext('Tic de fin');
gettext('**Contador de ciclos**');
gettext('Número de ciclos  \ncontados');
gettext('Valor  \nincrementado');
gettext('### Salidas');
gettext('Estado de la máquina');
gettext('Ciclo actual');
gettext('Cuenta finalizada');
gettext('Ejecutar el ciclo');
gettext('Número de ciclos  \na contar');
gettext('¿Estamos en el  \nciclo k-1?');
gettext('Solo se hace caso a la  \nentrada next si la  \nmáquina está encendida');
gettext('Nuevo ciclo');
gettext('Si es el ciclo k-1 y  \nse pide un ciclo  \nnuevo: Terminar');
gettext('Apagar la  \nmáquina');
gettext('Ciclo nuevo:  \nincrementar la cuenta');
gettext('El tic de start se saca  \npor exec para que se ejecute  \nel primer ciclo');
gettext('Si la máquina está  \napagada, las señales  \nde ejecución no pueden  \nsalir!');
gettext('Retrasar la señal un ciclo  \nmientras que se detecta si  \nla máquina ha finalizado o no');
gettext('Para automático de la  \nmáquina cuando ha terminado  ');
gettext('Paro externo');
gettext('**Tic de apagado**');
gettext('**Tic de encendido**');
gettext('**Inicializar**');
gettext('**Estado de la máquina**');
gettext('## Detector doble: flancos de subida y bajada\n\nSe detectan tanto los flancos de subida como de bajada y se emite los  \ntics por sus salidas correspondientes');
gettext('Señal de  \nentrada');
gettext('Reloj del  \nsistema');
gettext('## Syntax Char  \n\nSyntax block for receiving a specific character  \n\nWhen the character recived is what the block is expecting,  \nit gets activated, and the blocks becomes into a wire (transparent mode)  \nuntil it is reset\n\nIf the first received character is different from what it was expecting,  \nthen block blocks. it disconnect itself from the input until it is reset');
gettext('**Reset the block**');
gettext('**Input character**');
gettext('**Active state**  \n0: Block is not active  \n1: In Active mode');
gettext('Depending on the mode, the tic  \nreceived is outputed (transparent mode)\nor sent inside the block for further processing\n');
gettext('Transparent mode');
gettext('Ignored');
gettext('If the block is blocked, the tic  \nis ignored. Else the tic is sent  \nto the next stage for further processing');
gettext('**Expected character**');
gettext('State of the received character  \n0: Not the one was expected   \n1: The one that was expected  ');
gettext('Expected character  \nreceived: Change to   \nactive mode');
gettext('Other character received:  \nBlock the component');
gettext('**Block state**  \n0: Not blocked\n1: Blocked');
gettext('## PrintLn-bit: Print one bit plus a new line character  \n');
gettext('Bit to be transmited');
gettext('Transmit now! (tic)  \nActivate the machine');
gettext('Not connected');
gettext('**Block 1**  \nPrint the bit (0,1)');
gettext('The machine is busy either  \nthe block 1 is busy or  \nthe block 2 is busy');
gettext('**Block 2**  \nPrint new line char');
gettext('## PUTC-bit-stdout: Transmit one bit (STDOUT bus)  \n\nWhen activated, the bit input is sent as the character '0' or '1'  \nWhen not active, the stdout crossed the block (transparent mode)');
gettext('The bit to be transmitted should be  \nsyncronized with its transmit tic');
gettext('If the machine is ready and  \nthe next tic is received:  \nwe are done');
gettext('The machine is done');
gettext('Machine is on: send a character');
gettext('State of the machine  \n0: OFF  \n1: ON: Sending one character');
gettext('Character to transmit when  \nthe input bit is 1');
gettext('Character to transmit when  \nthe input bit is 0');
gettext('Select with character to transmit  \naccording to the input bit');
gettext('**Create the bus**  \nfrom the data and tic signals');
gettext('## PUTC: Transmit one character (STDOUT bus)\n\nWhen **idle**, the STDOUT bus crosses the component without modification    \n\nWhen the machine starts, the char is outputed and the state is changed to busy  \nWhen the transmitter is done (tic received in next)  the machine is turned off');
gettext('Start tic: The byte from the  \ninput char is transmited');
gettext('Char to be transmited');
gettext('State of the machine:  \n1: ON: transmitting  \n2: OFF: transparent mode  ');
gettext('If the machine is on  \nand the character has been  \ntransmitted: Turn it off');
gettext('## PUTC: Transmit one constant character ');
gettext('Apagado automática,  \ncuando la máquina  \ntermina');
gettext('Apagado manual');
gettext('Any command detected?');
gettext('End of command \ndetected');
gettext('No other cmds  \ndetected');
gettext('Unknown cmd  \ndetected');
gettext('Valid command detected  \nReset the error flip-flop');
gettext('## Syntax ELSE  \n \nDetect if the command is valid based on the state  \nof the commands detected. If no command has been  \ndetected when the /n char is received -->  \nit is an invalid command');
gettext('Commands state:  \n0: None of the commands  \n   have been detected  \n1: Valid command detected');
gettext('Empty Buffer condition  \nThere are 0 chars in the buffer');
gettext('The STDIN input stream is enable only if  \nthe machine in on and it is in edit mode');
gettext('The machine is on');
gettext('Edit model on');
gettext('Only printable chars  \nare allowd');
gettext('Enter key detected');
gettext('Delete key pressed');
gettext('The Delete key is only valid  \nif the buffer is not empty');
gettext('If the buffer is full,  \nno more chars are allowed');
gettext('Only chars when the buffer  \nis not full');
gettext('Echo the received characteres  \nto the STDOUT STREAM');
gettext('Characters sent to the STDOUT  \nstream when the delete key is presed');
gettext('Delete key received  ');
gettext('When the machine is on,  \nthe STDOUT stream is  \nused by the block');
gettext('Number of characteres  \nin de Buffer (Debug)');
gettext('**Start the machine**');
gettext('Stop the machine  \n(Abort)');
gettext('It only works if  \nthe machine is active');
gettext('### Machines stages  \n* Stage 0:  Edit mode  \n* Stage 1:  Dump mode');
gettext('Machine stage');
gettext('If in edit mode and the enter  \nkey is pressed: change to  the  \nnext stage');
gettext('If in dump mode and the dumping  \nis finished, change to the next  \nstage: done');
gettext('Insert the character  \nin the buffer. Also the  \nenter key (\\n)');
gettext('If the enter key is pressed  \nthe \\n character is inserted  \nif not, the received char');
gettext('Start the dumping of the  \nbuffer');
gettext('Proceed with the Next  \nchar to dump');
gettext('When the machine is off,  \nthe stdin bus is in  \ntransparent mode');
gettext('Number of characters  \nin the buffer');
gettext('Character dumped  \nfrom the buffer');
gettext('full Buffer condition  \nThere are 2 or more chars  \nin the buffer');
gettext('## InputLn-charx2  \nWaits for the user to enter a 2 characters command  \nThe user can use the Delete key  \nThe command is outputed when the enter key is pressed  ');
gettext('**TOP registers**  \nIt contais the address where  \nthe next byte will be stored');
gettext('Number of caracters  \nin the buffer');
gettext('Insert one byte  \nin the buffer');
gettext('Change in the  \nTOP reggister');
gettext('Byte to store in the buffer');
gettext('Remove the last bytes');
gettext('Start the Dumping of  \nthe buffer');
gettext('Dump the next byte');
gettext('**DUMP machine**');
gettext('In Dumping mode');
gettext('Dump addr');
gettext('Dump finished');
gettext('Condition:  \nCurrent dump addr is  \nequal to the top register?');
gettext('**YES**: The dump is finished!');
gettext('**NO**: Continue  \ndumping the memory');
gettext('Propagate the data_tic in  \nthe dump mode');
gettext('It is synchronized  \nwith the data from memory  \n(should be delayed 1 cycle)');
gettext('Memory for storing  \nthe bytes inserted');
gettext('Select the addr for  \naccesing the memory,  \naddr: If in dumping mode  \ntop: If inserting bytes');
gettext('Data to insert  \ninto the memory');
gettext('Select the accesing mode  \nfor the memory:  \n0: Reading in dumping mode  \n1: Writing in insert mode');
gettext('Data read from the  \nmemory when in dump  \nmode');
gettext('Tic: change in the buffer');
gettext('Data from the buffer');
gettext('Dumping finished!');
gettext('In dumping mode');
gettext('# 4BYTES BUFFER  \n\nBuffer for storing 4 byts, although only 3 can be used (the 4th is  \nused for indicating the buffer is full)  \n\nThe buffer has 3 operations:  \n* insert:  Storing the byte in the last posiition  \n* delete:  Delete the last byte  \n* dump: Dunmp the memory contents, from the first  \n  byte to the last one\n  The dump operation is done by a machine. It needs to  \n  receive the next signal to proceed for dumping the  \n  next value');
gettext('Maximum value');
gettext('Minimum value');
gettext('**Increment tic**  \nup button press and  \ncurrent value < Max');
gettext('**Decrement tic**  \nDown button pressed and  \ncurrent value > Min');
gettext('inc tic: 1  \ndec tic: 0\n');
gettext('Action detected!  \nEither inc or dec');
gettext('The counter  \nhas changed!');
gettext('Current value');
gettext('Value incremented!');
gettext('Value decremented!');
gettext('## Up-down counter with MAX and MIN limits\n\nThe counter is incremented when the up tic is received  \nand it has not already reached its maximum value  \n\nThe counter is decremented then the down tic is received  \nand it is not in its minimum value');
gettext('¿Estamos en el  \nciclo 1?');
gettext('Si es el ciclo 1 y  \nse pide un ciclo  \nnuevo: Terminar');
gettext('Only characteres in this  \nrange are valid: [32, 126]  \nThe others are ignored');
gettext('## STINFilter: Printable\n\nThe STDIn stream is filtered. Ontly printable  \ncharacteres are allowed on the STDIN-out stream\n\nCommands for the Enter (/n) and Delete are generated  \n(but that characteres are not sent to stdin output stream)');
gettext('Print-str');
gettext('Serial print-str');
gettext('Print a constant string of 15 or less characters');
gettext('16-bytes memory, initilized with a string');
gettext('Máquina de contar, de 4 bits, con entrada de stop');
gettext('Registro de 4 bits con entrada de reset');
gettext('Sumador de un operando de 4 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 4 bits');
gettext('Valor genérico constante (menos 1), de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('PrintLn-Char');
gettext('Serial debugger for characters. It prints the character + a line feed');
gettext(' Print a character + a new line');
gettext('## Debugger-PrintLn-char\n\nPrint a char on the console, followed by a new  \nline character');
gettext('2-bit number to print  \n(base-4. Simbols: 0,1,2 and 3)  ');
gettext('Tic for printing');
gettext('**Serial transmitter**');
gettext('Print the current  \nBase 4 number');
gettext('Insert the done signal  \nin the stdout BUS');
gettext('## PRINTLN-char: Char + \\n  \n\nWhen activated, the char + a new line are sent');
gettext('Print the char');
gettext('PrintLn-OK');
gettext('Print the OK message');
gettext('Print the OK + new line string');
gettext('## Debugger-PrintLn-OK\n\nPrint the OK message');
gettext('The machine is done  \nwhen the block  \nis done');
gettext('## PRINTLN-OK: Print the OK + new line string\n');
gettext('PrintLn-base-4');
gettext('Serial debugger for base 4 numbers (2-bits). It prints the number + a line feed');
gettext(' Transmit one bit as a character + a new line');
gettext(' Transmit two bits as a base-4 character (0-3)');
gettext('Agregador de 2 buses de 6 y 2-bits a bus de 8-bits');
gettext('Valor genérico constante, de 6 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('## Debugger-PrintLn-base-4\n\nPrint a 2-bit number on the console, followed by a new  \nline character');
gettext('## PRINTLN-bit-stdout: Transmit one bit (STDOUT bus)  \n\nWhen activated, the bit + a new line are sentd');
gettext('## PUTC-base4: Transmit one base-4 number \n\nWhen activated, the base-4 number is sent as a character (0-3)  \nIf not activated, the stdout bus is in transparent mode');
gettext('PrintLn-bit');
gettext('Serial Debugger for printing one bit + new line');
gettext('## Debugger-PrintLn-Bit\n\nPrint a bit on the console, followed by a new  \nline character');
gettext('hterm-bit-stdout');
gettext('Hardware terminal with only two commands: 0 and 1');
gettext('Read one bit from the input console, with edition (delete). Finish when enter is pressed');
gettext('When activated, it waits for a bit to be received codified in the '0' and '1' symbols by default. The received character is echoed (if valid)');
gettext('When activated, it waits for a bit to be received codified in the '0' and '1' symbols by default');
gettext('Detect one bit');
gettext('Get a constant character');
gettext('Print the Initial message');
gettext('**MAIN**');
gettext('Blank command');
gettext('Input the digits!');
gettext('## HTerm-bit\n\nHardware terminal with two commands: 0 and 1');
gettext('## INPUTLN-BIT-ECHO  \n');
gettext('State of the machine');
gettext('Received bit');
gettext('Blank cmd');
gettext('Select machine or  \ntransparent channel');
gettext('Wait for the '0' or '1' characters');
gettext('Machine state:');
gettext('The machine stops  \nwhen the user press  \nENTER or an abort cmd  \narrives');
gettext('Send the string for deleting  \nthe previous digit');
gettext('**BUFFER**  \nfor 1 bit');
gettext('**Buffer state:**  \n0: empty  \n1: Full  ');
gettext(' When a digit is  \n received the buffer  \n is full');
gettext('If the BS key is  \nreceived the buffer is  \nempty');
gettext('When the machine is  \nOFF the buffer is empty');
gettext('The input starts when  \nthe machine is turned on');
gettext('If a valid BS is received,  \nthe inputs is started');
gettext('The input is stoped when  \nthe machine is off');
gettext('Waits for the BS character  \nto be received');
gettext('BS received');
gettext('The BS is valid only if  \nthe buffer is full');
gettext('If the buffer is empty,  \nthe BS is ignored');
gettext('Wait for the ENTER  \ncharacter');
gettext('The ENTER key has  \nbeen pressed');
gettext('Depending on the state of  \nthe buffer, the ENTER means  \na blank command or a data command');
gettext('When the stop input  \nis activated, an  \nabort tic is sent');
gettext('## INPUT-BIT-ECHO  \n\nWhen the machine is turned on, it waits for one  \nof the two symbols (default: '0' and '1') and  \ncoded them into oen bit, that is returned and  \nthe machine is turned off\n\nThe valid symbols are sent through the  \nstdout');
gettext('**Echo generator**  \nOnly the valid characters  \nare echoed');
gettext('## INPUT-BIT  \n\nWhen the machine is turned on, it waits for one  \nof the two symbols (default: '0' and '1') and  \ncoded them into oen bit, that is returned and  \nthe machine is turned off');
gettext('Input machine state:  \n0: OFF  \n1: ON');
gettext('If the machine is ON and the  \nsymbol is valid, the tic is  \nallowed to pass...');
gettext('## GETC-BIT  \n\nRead one bit of information. By default the  \ncharacteres '0' and '1' are converted into  \n1 bit');
gettext('Check if the character received is one of  \nthe two symbols expected');
gettext('The current caracter matches the  \nconstant specified (level output)');
gettext('Tic ouptput. The current character  \nmatches the constant');
gettext('The character matches one  \nof the two expected symbols ');
gettext('Output the current data  \ntic to the rcv pin');
gettext('## GETC-CHAR  \n\nDetects if a constant CHAR has arrived');
gettext('Check if the character received is the one  \nexpected (set by the parameter. Default: 0)');
gettext('Charactter detected:  \nOutput the current data  \ntic to the rcv pin');
gettext('hterm-bit');
gettext('hterm-bitx2');
gettext('Hardware terminal with 2-bits binary commands');
gettext('Input 2-bits data in binary, with edition (BS and ENTER)');
gettext('Stack pointer for 2 elements');
gettext('Separador de bus de 2-bits en dos cables');
gettext('2-bits bidirection shift register (left - right)');
gettext('Agregador de 2 cables en un bus de 2-bits');
gettext('Valor genérico constante, de 10 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('## HTerm-bit-stdout\n\nHardware terminal with two commands: 0, 1 and blank  \nOther stdout blocks can be used');
gettext('**AUX STDOUT BUS**');
gettext('Combine the main serial stdin bus  \nwith the second');
gettext('When the inputln is active,  \nthe output is also sent  \nto the leds');
gettext('## INPUTLN-BITx2-ECHO  \n');
gettext('If a bit is inserted in the buffer,  \nand it is not full yet...');
gettext('The receiver is activated if  \nan active BS is received');
gettext('2-position stack register  \nIt constrols the buffer state');
gettext('This tic is generated only if  \nthe buffer in NOT empty');
gettext('Insert the received  \nbit in the buffer');
gettext('Machine state');
gettext('**BUFFER**: Bidirectional  \nshift register  \nIt stores the bits received  \nWhen the BS is received, one  \nbit is removed from the buffer');
gettext('Reset the register  \nwhen the machine starts');
gettext('##  SP-2  \nStack pointer for stacks of two elementos  \n');
gettext('The stack is empty');
gettext('The stack is full');
gettext('Push command');
gettext('Pop command');
gettext('According to the statck state,  the  \npush command is either ok or  \noverflow!');
gettext('According to the statck state,  the  \npop command is either ok or  \nunderflow!');
gettext('Load a new value  \nin the SP register');
gettext('**SP Register**');
gettext('reset the SP');
gettext('## 2-bits Shift register (left - right)\n\n');
gettext('Shift to the left (to MSB)');
gettext('Shift to the right (to lsb)');
gettext('Input when shifting right');
gettext('Input when shifting left');
gettext('Perform the shift  \n(etither right or left)');
gettext('virtual-toggle-button');
gettext('Virtual serial toggle button');
gettext('## Virtual Toogle button\n\nIt toggle the output only when the  \n\"t\\n\" command is received on the serial  \nline  \nAny other commands are ignored.  \nAll the command should end with \\n');
gettext('**Serial input**');
gettext('Then /n characters resets  \nthe machine in the next cycle');
gettext('### Toggle comand detector  \n\nIt genetared the t_exec signal  \nonly when the patter \"t\\n\" is  \nreceived... but only after reset');
gettext('02-bits');
gettext('Print-ram-2x1-bit');
gettext('Serial debugger for print the address (1-bit) and data (1-bit) of a 2x1 RAM memory');
gettext('## Debugger: RAM 2x1\n\nComponent for debugging a 2x1 RAM  \nPrint the Address A (1-bit) and the data D (1 bit) with  \nthe format: \n\n```\n[A]: D\n```\n');
gettext('**Address**');
gettext('**Data**');
gettext('Serial-rx');
gettext('Serial-tx');
gettext('stdin-bin-keyboardX4');
gettext('Stdin Binary keyboard, composed of 4 keys: 0, 1, backspace and Return');
gettext('FPGA internal pull-up configuration on the connected input port');
gettext('Detección de pulsación. Emite un tic cada vez que se aprieta el pulsador');
gettext('Codificador de 4 a 2, con prioridad. La salida zero se activa cuando ninguna entrada está activad');
gettext('Detector de flanco de bajada. Emite un tic cuando detecta un flanco descendente');
gettext('Circuito combinacional de 2 entradas y 8 salidas');
gettext('## STDIN-Bin-KeyboardX4\n\nKeyboard componente with 4-inputs: 0, 1, Backspace and ENTER\n\n');
gettext('**Return**');
gettext('**Backspace**');
gettext('**Key 1**');
gettext('**Key 0**');
gettext('**Pull-ups**');
gettext('Convert to positive  \nlogic');
gettext('**4-1 Codec**  \nOutput code:  \n0: Key 0  \n1: Key 1  \n2: Backspace  \n3: Return');
gettext('Conversion table:  \nGenerate the keycodes (8-bits)  for  \neach key');
gettext('Key pressed tic:  \nA tic is generated  \neverytime a key is  \npressed');
gettext('When no keys are pressed,  \nthe output is 1');
gettext('**Pulsador-tic**');
gettext('stdin-serial');
gettext('stdout-LEDs-8');
gettext('8-bits Binary stdout device. The information is shown on the LEDs');
gettext('Decodificador de 3 a 8, con salida en bus');
gettext('Habilitación de bus de 8 bits');
gettext('XOR bit a bit entre dos buses de 8 bits');
gettext('Corazón de bombeo de tics a con periodo paramétrico de milisegundos');
gettext('Timer in ms, with stop input');
gettext('3-bits up-down counter, with reset');
gettext('Comparador de un operando de 4 bits. Se compara si el operando es igual al parámetro');
gettext('Sumador  de 4 bits (sin acarreo)');
gettext('Multiplexor de 2 a 1 de 4 bits');
gettext('Valor genérico constante, de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Separador de bus de 4-bits en buses de 1 bits y 3 bits');
gettext('8x1 bits RAM memory with parallel output');
gettext('Demultiplexor de 1 bit, de 3 a 8 (salida de bus)');
gettext('Separador de bus de 8-bits en 8 cables');
gettext('Agregador de 8 cables de 1-bit a bus de 8-bits');
gettext('Multiplexor de 8 a 1, con entradas de bus');
gettext('Separador de bus de 8-bits en 1 buses de 6 bits y dos cables sueltos');
gettext('8-bits bus weight inverter');
gettext('## STDOUT LEDs\n\nShow the STDout in the LEDs  \nThe less significant bit of the charactere  \nreceived is shown at the current cursor position');
gettext('Converti STDOUT into STDIN for reading   \ninterpreting the received characteres  \nusing stdin blocks');
gettext('Process the  \nENTER character');
gettext('Other charactere received');
gettext('Reset the device:  \n* Clear all the leds  \n* Cursor at home');
gettext('BS received:  \nmove the cursor back  \none character  \n(no deleting)');
gettext('Data received!  \nWrite the lsb in the current  \ncursor position and  \nmove to the next position');
gettext('**Cursor controller**');
gettext('The cursor is visible  \nIt is inside the leds zone');
gettext('Current cursor  \nposition');
gettext('cursor Position  \nupdated');
gettext('Move the cursor back  \none character');
gettext('Move the cursos forward  \none character');
gettext('Move the cursor  \nto home');
gettext('Generate the cursor:  it is  \none pixel that is blinking');
gettext('Insert the next signal into  \nthe stdout bus');
gettext('Only take one cycle  \nto process the character');
gettext('Data to show in the LEDs  \nEach address correspond to  \none LED');
gettext('Combine the data  \nwith the cursor');
gettext('Write the bit in the current  \ncursor position');
gettext('Semiperiod');
gettext('**Arranque del**  \n**temporizador**');
gettext('**Salida de pulso**');
gettext('**Salida de tic**');
gettext('**Parametro del timer**  \nmilisegundos a esperar');
gettext('## Synchronous 8x1-bit RAM (Parallel)\n\n* Both the read and write operation are  \n  synchronous\n* The memory has parallel output');
gettext('Data input');
gettext('Write tic');
gettext('Paralell output');
gettext('standart reading');
gettext('**Each bit is store in its own flip-flop**');
gettext('stdout-serial');
gettext('Filters');
gettext('Getc');
gettext('InputLn');
gettext('Input_');
gettext('Print');
gettext('PrintLn');
gettext('Putc');
gettext('Regs');
gettext('Syntax');
gettext('Printable-nl-del');
gettext('Getc-bit');
gettext('Getc-char');
gettext('Getc-printable-char');
gettext('Receive a printable char');
gettext('## GETC-PRINTABLE-CHAR  \n\nDetects if the Char received is printable or not');
gettext('Printable char');
gettext('inputln-2xchars-echo');
gettext('inputln-bit-echo');
gettext('inputln-bitx2-echo');
gettext('inputln-char-echo');
gettext('Read one printable char from the input console, with edition (delete). Finish when enter is pressed');
gettext('When activated, it waits for a printable char to be received. This character is echoed (if valid)');
gettext('When active, waits for a printable char to be received');
gettext('Registro de 8 bits');
gettext('## INPUTLN-CHAR-ECHO  \n');
gettext('Received char');
gettext('**BUFFER**  \nfor 1 char');
gettext('## INPUT-Printable-char-ECHO  \n\nWhen the machine is turned on, it waits for a\nprintable character, which is then returned \n\nThe printable characteres are sent through the  \nstdout');
gettext('Received character');
gettext('## INPUT-BIT  \n\nWhen the machine is turned on, it waits for a  \nprintable char to arrive, which is returned and  \nthe machine is turned off');
gettext('input-bit-echo');
gettext('input-bit');
gettext('input-printable-char-echo');
gettext('input-printable-char');
gettext('asc');
gettext('Print-base4-bin');
gettext('Print a base4 number in Binary');
gettext('Máquina de contar, de 1 bit');
gettext('Registro de 2 bits');
gettext('First the MSB is  \nprinter, then the LSB');
gettext('Bit to print:  \n0: Bit 0  \n1: Bit 1');
gettext('2-state machine  \nTwo operation are needed');
gettext('Print the current  \nbit');
gettext('Store the nunmber  \nto print');
gettext('Base 4 number to print');
gettext('## PUTC-base4-bin: Transmit one base-4 number in Binary\n\nWhen activated, the base-4 number is sent as two binary  \ncharacters (0/1)');
gettext('Print-str-02');
gettext('Print a constant 1-char string');
gettext('2-bytes memory, initilized with a string');
gettext('Print-str-04');
gettext('Print-str-08');
gettext('Print-str-128');
gettext('Print-str-16');
gettext('Print-str-256');
gettext('Print a constant string of 256 or less characters');
gettext('256-bytes memory, initilized with a string');
gettext('Máquina de contar, de 8 bits, con entrada de stop');
gettext('Registro de 8 bits con reset');
gettext('Sumador de un operando de 8 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 8 bits');
gettext('Valor genérico constante (menos 1), de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Print-str-32');
gettext('Print-str-64');
gettext('Print-asc-02');
gettext('Print a constant string defined by 2 ascii bytes');
gettext('Memoria de dos bytes');
gettext('Memory with the string  \nto be transmited (in ASCII)');
gettext('Print-asc-04');
gettext('Print a constant string defined by 4 ascii bytes');
gettext('Print-asc-08');
gettext('Print a constant string defined by 8 ascii bytes');
gettext('8 bytes memory');
gettext('Print-asc-128');
gettext('Print a constant string defined by 128 ascii bytes');
gettext('128 bytes memory');
gettext('Print-asc-16');
gettext('Print a constant string defined by 16 ascii bytes');
gettext('16 bytes memory');
gettext('Print-asc-256');
gettext('Print a constant string defined by 256 ascii bytes');
gettext('256 bytes memory');
gettext('Print-asc-32');
gettext('Print a constant string defined by 32 ascii bytes');
gettext('32 bytes memory');
gettext('Print-asc-64');
gettext('Print a constant string defined by 64 ascii bytes');
gettext('64 bytes memory');
gettext('PrintLn-BitVar');
gettext('Print a Bit variable + LF');
gettext('## PRINTLN-bit-var\n\nPrint a Bit Variable. The output format is:  \n< Varname > < Bit > < LN >  \nWehre < Varname >  is a 1-char variable identifier\n\nExample: \"a1\\n\"');
gettext('Print the Variable  \nidentfifies');
gettext('Print the variable  \nbit value + \\n');
gettext('Before print, both variable name  \nand variable value are store into  \na register');
gettext('Store the variable  \nname');
gettext('Store the bit  \nvalue');
gettext('This print machine  \ngets busy as soon as  \nthe print gets high');
gettext('PrintLn-OK');
gettext('PrintLn-base-4');
gettext('PrintLn-bit');
gettext('PrintLn-char');
gettext('putc-base4');
gettext('putc-bit');
gettext('putc-char-const');
gettext('putc-char');
gettext('08-bits-shift-right-load-rst');
gettext('8bits shift right register with reset and paralell load');
gettext('Serial out');
gettext('**Reset**. The register is  \ninitialized with the INI  \nparameter');
gettext('Serial input');
gettext('Paralell data');
gettext('**load** the paralell  \ndata into the register');
gettext('**Shift** right 1-bit');
gettext('Syntax-ELSE');
gettext('Syntax-EOL');
gettext('Syntax End Of Line. Last block when detecting a command');
gettext('Last block:  \nIt is blocked with any  \ncharactere received');
gettext('The received char was  \nan END of LINE: OK!');
gettext('## Syntax EOL\n\nThis block should be the last one. It checks if the last correct  \ncharactere received is an end-of-line\n\nAs it is the last block, it always get blocked when a characterer  \narrives. If it is an EOL, it is send through the ok_tic\n');
gettext('Syntax-bit');
gettext('bit syntax block');
gettext('Extractor de 1 bit de un bus de 8 bits');
gettext('## Syntax Bit  \n\nSyntax block for receiving a bit ('0'/'1')\n\nWhen the character recived is a bit,  \nit gets activated, and the blocks becomes into a wire (transparent mode)  \nuntil it is reset\n\nIf the first received character is not a bit,  \nthe block blocks. it disconnects itself from the input until it is reset');
gettext('State of the received character  \n0: No bit symbol received  \n1: Bit received ');
gettext('Bit received:  \nChange to   \nactive mode');
gettext('**Block state**  \n0: Not blocked  \n1: Blocked');
gettext('Capture the bit  \nreceived');
gettext('Syntax-char');
gettext('Debug');
gettext('General');
gettext('Getc');
gettext('InputLn');
gettext('Input_');
gettext('Input_echo');
gettext('Print');
gettext('PrintLn');
gettext('Putc');
gettext('Syntax');
gettext('stdin-stdout');
gettext('2x1-bits-memory-test');
gettext('Detect changed on the input signal ');
gettext('Detect different clicks on the button: normal click, doble click or long click');
gettext('Pulsador con tic de cambio, pulsación y liberación de tecla');
gettext('Sincronizar las entradas de datos con el reloj del sistema');
gettext('Remove the rebound on a mechanical switch');
gettext('Test if a tic is received within time');
gettext('Timer in ms, with start and stop');
gettext('Corazón de bombeo de tics, cuyo periodo está especificado en micro-segundos. Solo se hace el bombeo cuando está habilitado');
gettext('Contador módulo M, ascendente, de 12 bits, con reset ');
gettext('2x1 bits RAM memory');
gettext('# 2x1 bits Memory\n\nExample of accesing to a 2x1 bits memory  \n* Click on button 1: Change the current addres (0/1)  \n* Click on button 2: Change the current data to write (0/1)  \n* Long click on button 2: Writing the current data into the current address\n\n');
gettext('**Current address**  \nIt is changed on everyt click  \nof button 1');
gettext('Show current address  \non LED7');
gettext('Long click on button 2  \nfor writing data on  \nthe memory');
gettext('Detect a change on the  \naddress');
gettext('**Print memory status**  \nThe current address and data  \nare printed on the console');
gettext('Print when there is a change  \nin the address');
gettext('or whenever there  \nis a write');
gettext('or after the reset');
gettext('**Current data**  \nIt is changed on every  \ntick of button 2');
gettext('Show current data  \non LED0');
gettext('## Memory');
gettext('Data from  \nthe memory');
gettext('## Change detector  \n\nIt emits the followings tics:\n\n* When there is a rising edge on the input signal\n* When there is a falling edge\n* When there is either a rising or falling edge');
gettext('## Button-click-3  \n\nDetect three different types of clicks in the Button:\n\n* Normal click  \n* Doble click  \n* Long click');
gettext('When the button is pressed  \nthe timer 1 is started');
gettext('If the button is pressed again  \nwithin the time, it is  \na doble click');
gettext('Timeout: It was  \nnot a doble click');
gettext('Check the current  \nbutton state: pressed  \nor not pressed');
gettext('Button state');
gettext('Button state:  \n1: Pressed  \n2: Not pressed');
gettext('Button is released:  \nwe have a click  \nIt is NOT a long click');
gettext('Button is still  \npressed: we do not know yet  \nif it is a click or long click');
gettext('Timeout for detecting a \ndoble click  \nAfter this time is not considered a  \ndoble click but two clicks in a row');
gettext('Wait for the release  \ntic');
gettext('Release tic has arrived  \nwithin time: it was a  \nnormal click  ');
gettext('In both cases it is  \nconsider a normal click');
gettext('The button has not been  \nreleased after the specified  \ntime: it is a long click');
gettext('**Outputs**');
gettext('## Timer-ms\n\nWhen the machine is active, it detects if  \nan input tic arrive within the specified time  \nIf so, another tic is sent to done. If no tic is  \nreceived within time (timeout), a tic is sent  \nto tout');
gettext('Start the machine');
gettext('Tic to detect within time');
gettext('Main timer');
gettext('Start the timer');
gettext('If a tic is received when  \nthe timer is still on,  \nlet it pass...');
gettext('The tic is delayed one unit  \nto prevent reache the timer  \nin the same cycle than start  \n(it can happens if the same tic is  \nconnect both to start and tic inputs)  ');
gettext('Stop the timer:  the tic  \nhas arrived in time');
gettext('The tic arrived in time  \nTic detected!');
gettext('No tic detected  \nwithin time');
gettext('tic: No input tic detected');
gettext('tic: input tic detected!');
gettext('Biestable de estado  \nde la máquina');
gettext('Mientras la máquina  \nesté apagada el  \ncontador está a 0');
gettext('Contador de tiempo  \nen unidades de  \nmilisegundos');
gettext('El tiempo ha expirado:  \napagar la máquina');
gettext('Unidades de tiempo:  \n1000 microsec = 1ms');
gettext('Al arrancar la máquina,  \neste corazón emite un  \ntic cada 1 ms');
gettext('**Parámetro**:  \nms de espera');
gettext('Sacar el tic de apagado de  \nla máquina por abort o done  \nsegún cómo haya sido');
gettext('Si es por stop: El timer ha abortado  \nSi no, es una terminación normal (timeout)');
gettext('**Parámetro**: Módulo del contador');
gettext('## Synchronous 2x1-bit RAM\n\n* Both the read and write operation are  \n  synchronous');
gettext('Address (0/1)');
gettext('Depending on the address,  \nsend the tic write to the  \ncorresponding flip-flop');
gettext('Demux-2-1');
gettext('Flip-Flop 0');
gettext('Flip-Flop 1');
gettext('Flip-flops are loaded with  \nthe data input when the  \nwrite tic is received');
gettext('Read operation:  \nOutput the selected  \nflip-flop');
gettext('The read data will be available  \non the next cycle');
gettext('Base4-counter');
gettext('Corazón de bombeo de tics a un frecuencia parametrica en Hz');
gettext('Contador módulo M, ascendente, de 2 bits, con reset ');
gettext('Generate tics');
gettext('Transmit the current number');
gettext('Count from 0 to 3');
gettext('## Base 4 counter\n\nIt prints the count from 0 to 3 on  \nthe console');
gettext('Hello-world');
gettext('## Hello World\n\nIt prints the string \"Hello World\"  \nafter the reset');
gettext('Hterm-toggle-LED');
gettext('# Toggle-led\n\nThe LED7 is toggle with the cmd t  \nAny other command will show the  \n\"unkwnon command\" message\n\n');
gettext('### Example\n\n```\nHterm 0.5\n? for help\n>?\nHterm 0.5-Toggle\nAvailable commands:\n? : This help\nt : Toogle the state\n\n>t\n1\nOK!\n>t\n0\nOK!\n>hd\nUnknown command\n>\n```');
gettext('Mini-local-input-console-test-01');
gettext('## Keyboard STDIN test: HTerm-LEDs\n\nThe 2-bits binary input is shown in two LEDs  \nThe serial consola and the local keyboard STDIN  \nare used');
gettext('Mini-local-input-console-test-02');
gettext('## 2-bits binary to decimal conversor\n\nThe 2-bits binary numbers are converted into  \nit decimal representation (base 4: 0,1,2 and 3)  \nThe numbers are introduced either by the serial console  \nor the keyboard  \n\nThe terminal edition is shown on the console and in  \nthe external leds');
gettext('Print the 2-bits number  \nas a decimal digit');
gettext('Show the terminal in  \nthe LEDs console');
gettext('Keyboard input');
gettext('Show the number in the  \nLEDs (in binary)  ');
gettext('Number entered');
gettext('The LEDs terminal es  \nreset on every prompt  \nrequest');
gettext('Print the entered number on the  \nconsole');
gettext('Previous command finished  \nRequest for the prompt');
gettext('hterm-bit-stdout-test-1-2x1-memory');
gettext('2x1 bits RAM memory with parallel output');
gettext('Comparador de dos operandos de 1 bit');
gettext('Blank cmd:  \nDump the memory');
gettext('## Memory dump');
gettext('Select the address for accesing  \nthe memory:  \n0: Addres for writing  \n1: Adress for reading');
gettext('Address for reading');
gettext('After reading,  \nprint the data');
gettext('Data to read');
gettext('Write comand');
gettext('Writing finished');
gettext('Write pointer');
gettext('The reading address  \nis equal to the current  \nwrite pointer');
gettext('Conditional print:  \nIf addr == wp:  \n  print(\"*\")');
gettext('## Print the address and its content\n\nOne line is printed, with the address on the left  \nand its content on the right. An * is printed if this  \nis the current address to write\n\n```[0]: 0```');
gettext('Before dumping the memory, the  \nwrite pointer is incremented');
gettext('## HTerm  \n\n0,1 and blank commands');
gettext('## Synchronous 2x1-bit RAM (Parallel)\n\n* Both the read and write operation are  \n  synchronous\n* The memory has parallel output');
gettext('hterm-bit-stdout-test-2-one-element-stack');
gettext('Stack pointer for 1 element');
gettext('Blank cmd:  \npop');
gettext('## 1 element stack\n\nSimple stack composed of 1 bit. The interface is the HTerm  \nThe digit introduce are store in the stack (only the first)  \nIf another element is entered when the stack is full, the  \noverflow message is gotten.   \n\nThe blank command is used for poping the element. A pop command  \nentered when the stack is empty will produce an undeflow message');
gettext('Stack pointer for   \n1 element stack');
gettext('Turn on the LED when the  \nstack is full');
gettext('Turn on the LED when the  \nstack is empty');
gettext('Bit in the stack');
gettext('Command finished  \nPrint the prompt');
gettext('Bit to store  \nin the stack');
gettext('**Stack state:**  \n0: empty  \n1: Full');
gettext('##  SP-1  \nStack pointer for stacks of only 1 element!  \n');
gettext('The push cmd is valid is the  \nstack is empty');
gettext('The pop cmd is only valid  \nif the stack is full');
gettext('According to the stack state,  the  \npop command is either ok or  \nunderflow!');
gettext('hterm-bit-stdout-test-3-two-elements-stack');
gettext('## 2 elements stack\n\nStack composed of two elementos of 1 bit. The interface is the HTerm  \nThe digit introduce are store in the stack\nIf another element is entered when the stack is full, the  \noverflow message is gotten.   \n\nThe blank command is used for poping elements. A pop command  \nentered when the stack is empty will produce an undeflow message');
gettext('Stack pointer for   \na 2 elements stack');
gettext('hterm-bit-test-1');
gettext('# HTerm-bit\n\nMini-terminal with two commands: 0 and 1  \nThis commands are used for turning a LED on/off');
gettext('Store the received  \ncommand');
gettext('hterm-bitx2-test-1-LEDs');
gettext('## HTerm  \n\n2-bits data and blank commands');
gettext('## hterm-bitx2 Test: LEDs\n\nThe 2-bits binary input is shown in two LEDs  \nThe blank comands reads the value stored');
gettext('Print stored value');
gettext('Store the number entered');
gettext('ok-button');
gettext('## PrintLn OK Test\n\nIt prints the string \"OK\" when the button  \nis pressed');
gettext('virtual-toggle-button-test');
gettext('## Virtual Toggle Button Test 1: LED  \n\nChange the LED using the Virtual serial toggle button ');
gettext('01-print-matrix');
gettext('Máquina de wait');
gettext('**Reset, HOME**  \n**CLS, GREEN**');
gettext('* Reset: \"\\033[0m\"  \n* Home:  \"\\033[H\"\n* CLS: \"\\033[2J\"\n* Green color (fg): \"\\033[32;1m\"\n\n');
gettext('https://www.youtube.com/watch?v=kIXNpePYzZU\n\nCall trans opt: received. 2-19-98 13:24:18 REC:Log>  \nTrace program: running\n');
gettext('## Example 1: Matrix (Opening scene)  \n\nTwo messages are printed on the console in green color  \nThe printing emulates a slow terminal  \n\n');
gettext('**Message 1**');
gettext('**Message 2**');
gettext('Apagado de la máquina');
gettext('02-Button-state-ANSI');
gettext('## Example 2: Big button state  \n\nThe state of the pushbutton is shown in big ANSI digits  \n');
gettext('The tic activates on print  \nor another depending on the state  \nof the button');
gettext('03-cowsay-bin');
gettext('## Example 3: Cowsay  \n\nCow say the state of the button :-)\n');
gettext('The button is pressed');
gettext('The button is released');
gettext('04-NOT-truth-table');
gettext('## Example 4: Not gate truth table  \n\nThe NOT truth table is generated automatically\n');
gettext('**Start here**');
gettext('Count machine');
gettext('## Circuit to simulate');
gettext('**New line**');
gettext('05-ram-2x1-bit-test-term');
gettext('## Write-Mode STDOOUT');
gettext('Writting addr');
gettext('**Input data**');
gettext('## Dump-Mode STDOOUT');
gettext('Dump data');
gettext('## Write Mode Machine');
gettext('## Dump Mode Machine');
gettext('Select which address to use  \ndepending on the mode');
gettext('# Terminal for a 2x1 bits Memory\n\nFirst you are asked for the memory values (writing mode)  \nThen the memory values are printed on the console  \nThe process is repeated indefinitely\n\n');
gettext('06-Hcalc-acumulator');
gettext('2-ops 2-bits adder (no carry)');
gettext('Wait for the user to enter  \nthe '1' or '0' commands');
gettext('Print the welcome message');
gettext('Total msg');
gettext('# HCALC-0.1-acumulator\n\n1-bit calculator. It calculates the adition of bits  \nThe result is shown in 1 bit  ');
gettext('Operand to add');
gettext('Do the operation!');
gettext('2-bits acumulator');
gettext('Calculate op + acc');
gettext('acc = acc + op');
gettext('Print the least significant  \nbit of the acumulator');
gettext('Print the Total value');
gettext('07-Hcalc-terminal');
gettext('# HCALC-prompt\n\n1-bit calculator.  The user inputs two operands');
gettext('Primer operando');
gettext('Segundo operando');
gettext('Máquina de dos estados:  \n0: Captura del primer operando  \n1: Captura del segundo operando');
gettext('Suma conbinacional');
gettext('Resultado de la  \nsuma (en 1 bit)');
gettext('Primer cálculo,  \ntras el reset');
gettext('Resto de cálculos');
gettext('08-Hcalc-expresion');
gettext('Puerta XOR');
gettext('# HCALC-expresion\n\n1-bit calculator.  The user inputs two operands');
gettext('Según el operando que toque,  \nse imprime un mensaje u otro');
gettext('La suma de numeros  \nde 1 bit se implementa  \ncon una puerta XOR');
gettext('Según el operando que toque,  \nse almacena en un biestable  \nu otro');
gettext('09-Hcalc-stack');
gettext('2-bits stack pointer');
gettext('# HCALC: Stack example 1\n\nAdding two 1-bit numbers using the stack  \nIt is divided in two stages:  \n\n1) Fist, the elements are introduce by  \nthe user and stored on the stack\n\n2) Secod, the operands are read from the  \nstack, added and printed the result on  \nthe console');
gettext('Pushing 2 operands  \ninto the stack');
gettext('Poping 2 operands  \nfrom the stack');
gettext('PUsh the next  \noperand');
gettext('Push the current  \noperand');
gettext('Ask the user to  \nenter the current  \noperand');
gettext('### Stack Pointer');
gettext('Push data  \non the stack');
gettext('### Memory');
gettext('One cycle after pushing the  \noperando, push the next one');
gettext('One cycle after reading,  \npop the next operand');
gettext('Operand to pop:  \n0: First  \n1: Second');
gettext('Send the read tic to the   \ncorresponding biestable  \nfor storing the operand');
gettext('First operand');
gettext('Second operand');
gettext('Perform the  \naddition of the  \ntwo operands');
gettext('**Printing the Result**');
gettext('2-bit register  \nCurrent posicion');
gettext('Value 3 is used when  \nthe stack is empty');
gettext('## 2-bits Stack Pointer\n\nIt only have 3 position for storing information:  \n0,1 and 2. The 3 is used for indicaning empty stack\n\nIt is it initial value (3 = -1)\n\nWhen the up tic is received, the sp is incremented (but it will never  \nbe higher than its maximum value of 2) and the push tic is emitted  \n(on the next cycle) for being synchronyzed with the sp value\n\n');
gettext('When the down tic is received, the pop tic is emitted and then the sp is decremented  \n(but it cannot be lower than -1). Therefore the pop tic comes before the sp is  \ndecrement. The external circuit has one cycle to read the current value at the top. In  \nthe next cycle the sp is decremented. This approach makes it very easy to implement the  \npop operation on a memory\n\nThe changed tic is emitted whenever the sp has changed  \n(either increased or decreased)');
gettext('Incremented value of  \nthe sp');
gettext('Decremented value  \nof the sp');
gettext('Current sp value');
gettext('Select the value  \nfor updating the  \ncurrent sp');
gettext('valid Change in the  \ninput tics');
gettext('There was a change  \nin the sp register');
gettext('2-1 coder');
gettext('The sp is NOT at TOP  \nand up-tic is received');
gettext('It is ok to  \nincrement the sp');
gettext('The sp is NOT EMPTY  \nand down-tic is received');
gettext('It is ok to  \ndecrement the sp');
gettext('10-Hcalc-two-elements-stack');
gettext('## HCalc stack  \n\nTwo operands stack calculator. The elements are 1-bit  \nFirst you should introduce two bits and the issue the  \nblank commad. The sum is printer or an underflow error\n\n');
gettext('Operation state:  \n0:  OK\n1: Underflow!  \nEverytime a new command is started  \nthe error is cleared');
gettext('**Máquina para leer**  \n**los dos operandos**');
gettext('Current operand:  \n0: First operand  \n1: Second operand  ');
gettext('According to the error, the done tic  \nis sent to one block or another');
gettext('pop the current operand');
gettext('Store the operand in different  \nflip-flips');
gettext('Operand 0');
gettext('Operand 1');
gettext('Add the two  \n1-bit operators');
gettext('Read next operand');
gettext('Result');
gettext('11-Hcalc-2bits-acumulator');
gettext('Sumador  de 2 bits (sin acarreo)');
gettext('Add command');
gettext('Show the result on  \nthe LEDs');
gettext('**Print the result**');
gettext('The operand introduce by the  \nuser is only 1-bit. Convert  \ninto a 2-bits number');
gettext('The result is printed either  \nit is a blank comand or an  \nadd command');
gettext('Add command:  \njust capture the  \nop1 + op2 value ');
gettext('operand 1');
gettext('Operand 2');
gettext('## HCalc 2-bits accumulator\n\nA 2-bits acumulator is used for adding the 0's and 1's introduced  \nin the Hardware terminal. The result is printed on the console  \nin binary\n');
gettext('getc-bit-01');
gettext('# GETC-BIT: Example 1\n\nReceive a bit of information, coded into the characters '0' and '1'  \nWhen the characters '0' or '1' are received, a tic is emited by rcv  \nand the bit is loaded into the flip-flop\n\nTherefore, using the keys \"1\" and \"0\" we control the state of the  \nLED0\n');
gettext('A bit has arrived.  Store it  \nin the Flip-flop for showing  \nin the LED');
gettext('getc-bit-02');
gettext('# GETC-BIT: Example 2\n\nTwo independent bits are used to control two leds. The first one  \nis controlled by keys '0' and '1' and the second one by keys 's' and  \n'n'\n\nTwo getc-bit modules in cascade are used\n');
gettext('Bit received');
gettext('Bit codified in the  \n'0' and '1' characters');
gettext('Bit codified in the  \n's' and 'n' characters');
gettext('getc-bit-03');
gettext('Baliza luminosa de 2 leds. Parpadean alternativamente a 2Hz cuando se activa');
gettext('Bombear 2 bits por segundo');
gettext('Corazon genérico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)');
gettext('## Test Circuit\n\nIt just blinks the two LEDs,  \nwhen started');
gettext('# GETC-BIT: Example 3\n\nExample of starting a circuit by command line  \nThe circuit to start is a simple one: two blinking LEDs  \nAfter the reset, a message is printed on the console asking  \nif the test circuit should be estarted or no  \n\nIf the user press \"y\" (in lower case) the test circuit is turned on  \nand an ok message is printed on the console\n\nIf the user press \"n\" (in lower case) a message is printed on the  \nconsole and the reception of serial comands is disabled');
gettext('Circuit state:  \n0: Disabled  \n1: Enabled  ');
gettext('Receiver state:  \n0: Disabled  \n1: Enabled');
gettext('Enabling the serial  \nline');
gettext('If \"y\" or \"n\" characters are  \nreceived, the serial line  \nis disabled');
gettext('**Initilialization**');
gettext('Sendd the tic to  \nyes or not depending  \non its value  \nyes: 1  \nno : 0 ');
gettext('After printing the  \ninitial message, the  \nserial line is enabled');
gettext('Initial question');
gettext('NO message');
gettext('YES message');
gettext('**Baliza luminosa**\n\nParpadeo de los LEDs alternativamente a 2Hz, cuando están habilitados ');
gettext('Creado a partir de un **corazón  \ngenérico**, dando el valor adecuado  \na su parámetro frecuencia');
gettext('getc-char-01');
gettext('Multiplicador de cables. Genera un bus de 4 bits, a patir del bit de entrada');
gettext('# GETC-CHAR: Example 1\n\nThe keys \"1\", \"2\" and \" \" (space) are detected  \nAll the rest are ignored  \nWhen the \"1\" is detected, the LED7 is turn ON\nwhen the \"2\" is detected, the LED7 is turn OFF\nwhen the \" \" is detectaed, the LEDs 0 - 3 are toglled  \n\nThe GETC-CHAR blocks can be chained. Whem a block detect is character, the  \ncorresponding tic signal is removed from the transparent channel and  \nemited to its rcv output');
gettext('Characters different than \"1\", \"2\",  \nor \" \" are received here... but  \nthey are ignored!');
gettext('Tic emitted when the  \n\"2\" char is detected');
gettext('State of the LED 7  \n0: OFF  \n1: ON');
gettext('Tic emitted when the  \n\"1\" char is detected');
gettext('Tic emitted when the   \n\" \"  char is detected');
gettext('LEDs state:  \n0: Group OFF  \n1: Group ON  ');
gettext('Send the 1-bit input  \nto the 4 outputs  ');
gettext('getc-char-02');
gettext('# GETC-CHAR: Example 2\n\nExample of use of the Input and Output console\n\nWhen the 'h' key is pressed, a greeting message is printed  \non the console  \nIf the 'm' key is pressed, the menu is printed again  \nAny other key pressed will print an error message  ');
gettext('Any key diffent than 'h' or 'm' will  \nissue the error cmd');
gettext('**Greetings command**');
gettext('**Menu command**');
gettext('The menu is printed after the reset or  \nwhen the key 'm' is pressed');
gettext('**INPUT CONSOLE**');
gettext('**OUTPUT CONSOLE**');
gettext('getc-char-03');
gettext('# GETC-CHAR: Example 3\n\nTesting a NOT gate\n\nThe key \"1\" set the input to 1   \nThe key \"2\" set the input to 0  \n\nWhenever there is a change in the input, both  \nthe input and output are printed on the console\n');
gettext('**Input**');
gettext('**output**');
gettext('Show the menu  \nafter reset');
gettext('Print the initial  \nstate: input - output');
gettext('Set input to 1');
gettext('Set input to 0');
gettext('## Circuit to TEST');
gettext('Detect a change in the input  \nif so, print input and output');
gettext('Show the output in the LED');
gettext('getc-pritnable-char-01');
gettext('# GETC-PRINTABLE-CHAR: Example 1\n\nOnly the printable characteres received are  \nprinted on the console. The rest are ignored  ');
gettext('inputln-bit-test-01-led-on-off');
gettext('# INPUTLN-BIT: Example 1\n\nMini-terminal with two commands: 0 and 1  \nThis commands are used for turning a LED on/off');
gettext('inputln-bitx2-test-01-LEDs');
gettext('## INPUTLN-BITx2-ECHO. Example 1\n\nThe user introduce 2 bits. When the Enter is pressed  \nthese bits are shown in the LEDs\n');
gettext('inputln-char-test-01-LEDs');
gettext('# INPUTLn-PRINTABLE-CHAR-echo Test: Example 2\n\nCheck the inputln printable char echo block  \nThe printable character enter by the user is  \nshown in the LEDs\n');
gettext('Activate the input block');
gettext('Show the received  \nprintable char in  \nthe LEDs');
gettext('inputln-charx2-cmd-echo');
gettext('# INPUTLn-Charx2 Test: Echoing the commands\n\nThe user enters 2-characters commands, in edit mode. When the command is ready,  \nthe Enter key is pressed and the command is stored in a buffer. Then it is  \nprinted on the console\n');
gettext('### Example\n\n```\n>ls\ncmd: ls\n\n>hd\ncmd: hd\n```');
gettext('Enter pressed:  \nPrint the response');
gettext('Dump the command to  \nthe console');
gettext('When the dump tic is received  \nthe buffer is outputed,  \nchar by char');
gettext('The next char is outputed  \nwhen the previous one has  \nalready been printed on the  \nconsole');
gettext('The command is printed  \non the console, char by  \nchar');
gettext('Print one char of the  \ncommand');
gettext('Input-bit-01');
gettext('# INPUT-BIT: Example 1\n\nExample of the input-bit block. The state of the LED0  \nis set by the user after the initializacion, only once  \nby pressing the '1' or '0' keys  \nThen the OK! message is printed and no more read on the  \nconsole are allowed');
gettext('Start the input machine  \nafter the reset');
gettext('Wait for one bit from  \nthe user');
gettext('Set the LED state with  \nthe value given by user');
gettext('Input is done. Print the  \nOK! message');
gettext('Prit the OK message after  \nthe user has set the state  \nof the LED');
gettext('Abort button. The  \ninput block is stoped');
gettext('Input-bit-02');
gettext('# INPUT-BIT: Example 2\n\nExample of activation of two different input  \nunits. The first one wait for the user to  \nenter \"0\" or \"1\". The second one waits for  \nthe \"y\" or \"n\" symbols  \nWhen finished, the selected LED is blinking or not  \naccording to the user input');
gettext('Print the initial message  \nafter the reset');
gettext('Wait for one bit from  \nthe user: Select LED');
gettext('Select the  \nactive LED');
gettext('LED is selected');
gettext('Initial message');
gettext('Wait for the blinking  \nstate (yes/no)');
gettext('Blinking state');
gettext('Example of the console output:\n\n```\n> Select LED (0/1): \n> Activate blinking? (y/n) \nOK!\n\n```');
gettext('Blink enable/disable');
gettext('Select the LED  \nto blink');
gettext('**ALL starts HERE!!**');
gettext('Second question');
gettext('Input-bit-03');
gettext('Demultiplexor de 1 bit, de 2 a 4');
gettext('**Number**');
gettext('**Number of LEDs**');
gettext('**Count machine**  \nExecute 4 times  \nthe input machine');
gettext('Print messages on the screen  \nThen execute the input machine');
gettext('Wait for the state of the  \nLED n from the console');
gettext('Change the led  \nstate');
gettext('Select the LED');
gettext('LED state, from  \nthe user');
gettext('# INPUT-BIT: Example 3\n\nThere is one input-bit block that is started 4 times by a  \ncount machine. Each user input correspond to the state of one  \nof four LEDs. This is the output in the console:\n\n```\nLED0 state? (0/1) \nLED1 state? (0/1) \nLED2 state? (0/1) \nLED3 state? (0/1) \nOK\n```\n\n');
gettext('**OK message**');
gettext('Input-bit-04');
gettext('# INPUT-BIT: Example 4\n\nTwo chained inputs. The firt bit is used for seting the first  \nLED nad the second bit is for the other LED. The two bits  \nare printed on the stdout');
gettext('Start the second  \nmachine ');
gettext('**Print the bit**');
gettext('Input-bit-05');
gettext('# INPUT-BIT: Example 5\n\nAsking the question y/n?. Depending on the answer, one  \nstring or another is printed');
gettext('**START HERE**');
gettext('Repeat the sequence');
gettext('input-printable-char-01');
gettext('# INPUT-PRINTABLE-CHAR Test: Example 1\n\nCheck the input printable char block  \nWhen activated, the printable char is printed on  \nthe console. ');
gettext('input-printable-char-echo-01');
gettext('# INPUT-PRINTABLE-CHAR-echo Test: Example 2\n\nCheck the input printable char echo block  \n');
gettext('01-input-bit-button');
gettext('**Read one bit**:  \nWait for the user to  \ntype '1' or '0'');
gettext('Show the received bit  \non the LED');
gettext('Ask for another bit');
gettext('# INPUT-BIT-echo: Example 1\n\nExample of the input-bit-echo block. The state of the LED0  \nis set by the user by pressing the '0' or '1' keys  \nIf valid inputs are received, they are printed (echoed) in the  \nconsole');
gettext('02-input-bit-hterm-01');
gettext('Set the LED according  \nto the command (0/1)');
gettext('Valid command: OK!');
gettext('# INPUT-BIT-echo: Example 2\n\nSimple terminal with only two commands: 0 and 1  \nIt prompts the user to enter the commands. All the  \nkeys are ignored except '1' and '0' that correspond  \nto the valid commands, used to turn the LED on or off\n');
gettext('03-input-bit-hterm-02');
gettext('# Terminal\n\nSmall terminal with two commands:  \n'1' for toggling the LED and  \n'0' for reading the LED's state');
gettext('**Message printing the led state**\n\nString + Bit + Char (new line)');
gettext('Initial \ntic');
gettext('LED state msg');
gettext('Test');
gettext('Print-01-two-buttons');
gettext('# PRINT: Example 1\n\nExample of the PRINT block:  printing a  \nconstant string\n\nTwo differente messages are printed, according  \nto the button pressed\n\n* Button 1 ---> Message 1  \n* Button 2 ---> Message 2');
gettext('**Print message 1**');
gettext('**Print message 2**');
gettext('**Print-ASC** block: The message should be in ASCII in a memory block\n\nAscii codes of a string can be easily obtained by running the following  \nline in python3\n\n\n```pythonn\nprint(\" \".join([\"{:02X}\".format(ord(i)) for i in \"Message\"]) + \" 00\")\n```');
gettext('Print-02-two-buttons-ASCII-art');
gettext('# PRINT: Example 2\n\nSame circuit than the example 1 but the messages has been  \nchanged for big numbers in ASCII art:\n\n* Message for the button SW1:\n\n```\n  _ \n / |\n | |\n | |\n |_|\n```\n\n* Message for the button SW2:\n\n```\n  ____  \n |___ \\ \n   __) |\n  / __/ \n |_____|\n```\n\n');
gettext('Print-03-menu');
gettext('# PRINT: Example 3\n\nAn initial message and a menu are printed initially,  \nafter the reset\n\nWhen the button sw1 is pressed the led is toggle and the  \nOK message is printed on the console\n\nWhen the button sw2 is pressed, the led stated is printed  \non the console');
gettext('This message is printed just  \none time, after the reset');
gettext('**Print the Menu**');
gettext('** Button 2 pressed**');
gettext('** Button 1 pressed**');
gettext('Print-04-str-two-buttons');
gettext('# PRINT: Example 4\n\nExample of the block print-str: printing the string  \npassed as a parameter\n\nDepending on the button pressed, 1 or 2, the messages  \n\"B1 \" or \"B2 \" are printed on the console\n');
gettext('Print-base4-bin-01-counter');
gettext('# PRINT-base4-bin: Example 1: Counter\n\nPrinting the numbers from 0 to 3 in binary');
gettext('Show the number  \nin the LEDs');
gettext('Print-base4-bin-02-two-buttons');
gettext('# PRINT-base4-bin: Example 2: Two buttons\n\nPrint the state of the two buttons as a 2-dibgit binary number  \nIt is printed on every button's change');
gettext('Number to print  \n(in binary)');
gettext('There is a change on  \nsome button');
gettext('Print in  \nBinary');
gettext('asc');
gettext('str');
gettext('Test-print-asc-02');
gettext('## Test Print-asc-02 \n\nTesting the Print-asc-2 block  \nWhen the button is pressed the charachter  \n'X' is sent');
gettext('Test-print-asc-04');
gettext('## Test Print-asc-04 \n\nTesting the Print-asc-4 block  \nWhen the button is pressed the string    \n\"OK\\n\" is printed!');
gettext('Test-print-asc-08');
gettext('## Test Print-asc-08 \n\nTesting the Print-asc-8 block  \nWhen the button is pressed the  \nmessage is printed');
gettext('Test-print-asc-128');
gettext('## Test Print-asc-128\n\nTesting the Print-asc-128 block  \nWhen the button is pressed the  \nmessage is printed');
gettext('Test-print-asc-16');
gettext('## Test Print-asc-16 \n\nTesting the Print-asc-16 block  \nWhen the button is pressed the  \nmessage is printed');
gettext('Test-print-asc-256');
gettext('## Test Print-asc-256\n\nTesting the Print-asc-256 block  \nWhen the button is pressed the  \nmessage is printed');
gettext('Test-print-asc-32');
gettext('## Test Print-asc-32 \n\nTesting the Print-asc-32 block  \nWhen the button is pressed the  \nmessage is printed');
gettext('Test-print-asc-64');
gettext('## Test Print-asc-64 \n\nTesting the Print-asc-64 block  \nWhen the button is pressed the  \nmessage is printed');
gettext('Test-print-str-02');
gettext('## Test Print-str-02 \n\nTesting the Print-asc-2 block  \nWhen the button is pressed the charachter  \n'X' is sent');
gettext('Test-print-str-04');
gettext('## Test Print-str-04 \n\nTesting the Print-str-4 block  \nWhen the button is press, the \"ok\"  \nstring is printed (it is also printed  \nafter the reset)');
gettext('Test-print-str-08');
gettext('## Test Print-str-08\n\nTesting the Print-str-8 block  \nWhen the button is press the  \nstring is printed (it is also printed  \nafter the reset)');
gettext('Test-print-str-128');
gettext('## Test Print-str-128\n\nTesting the Print-str-128 block  \nWhen the button is press the  \nstring is printed (it is also printed  \nafter the reset)');
gettext('Test-print-str-16');
gettext('## Test Print-str-16\n\nTesting the Print-str-16 block  \nWhen the button is press the  \nstring is printed (it is also printed  \nafter the reset)');
gettext('Test-print-str-256');
gettext('## Test Print-str-256\n\nTesting the Print-str-256 block  \nWhen the button is press the  \nstring is printed (it is also printed  \nafter the reset)');
gettext('Test-print-str-32');
gettext('## Test Print-str-32\n\nTesting the Print-str-32 block  \nWhen the button is press the  \nstring is printed (it is also printed  \nafter the reset)');
gettext('Test-print-str-64');
gettext('## Test Print-str-64\n\nTesting the Print-str-64 block  \nWhen the button is press the  \nstring is printed (it is also printed  \nafter the reset)');
gettext('PrintLn-BitVar-01');
gettext('## PrintLN-BitVar-01\n\nThe state of the SW1 button is printed on the  \nconsole. The variable a is assigned. In the console you will  \nsee the value of the a varible:  \n```\na1\na0\n...\n```\n\n');
gettext('PrintLn-base4-01-counter');
gettext('# PRINTLN-base4: Example 1\n\nPrinting the numbers from 0 to 3');
gettext('PrintLn-bit-01-button');
gettext('# PRINTLN-bit: Example 1\n\nExample using the PrintLN-bit block\nPrinting the state of the Button 2 when the  \nbutton 1 is pressed');
gettext('Println-ok-01-button');
gettext('Putc-Base-4');
gettext('Putc-bit');
gettext('Putc-char');
gettext('putc-base4-01');
gettext('# PUTC-BASE4-stdout: Example 1\n\nPrinting the 0,1,2 and 3 numbers');
gettext('putc-bit-01');
gettext('Transmit the bit as  \na character ('1' or '0')');
gettext('Bit to transmit  \nIs changed every tic: 0,1,0...');
gettext('Transmit the current bit');
gettext('# PUTC-BIT-stdout: Example 1\n\nSending alternated bits: 0,1,0,1,0,1...  \nRate of Speed: 2 Bits per seccond (2 Hz)');
gettext('putc-bit-02');
gettext('Transmit the button state');
gettext('# PUTC-BIT-stdout: Example 2\n\nThe button 1 is sampled at 10Hz and its state is transmitted');
gettext('State of the button:  \n0: Not pressed  \n1: Pressed');
gettext('putc-bit-03-button-changed');
gettext('Transmit one bit as a characters');
gettext('# PUTC-BIT-stdout: Example 3\n\nThe button state is transmited whenever there is a changed  \non it: either pressed or released');
gettext('Button state:  \n0: Not presssed  \n1: Pressed');
gettext('The button state  \nhas changed');
gettext('Transmit the  \nbutton state');
gettext('The state is transmitted  \ninitially and whenever  \nthere is a change  \nin the button ');
gettext('putc-bit-04-two-buttons');
gettext('# PUTC-BIT-stdout: Example 4\n\nWhen the button 1 is pressed, a 0 is sent  \nWhen the button 2 is pressed, a 1 is sent  ');
gettext('Send '0' when the  \nbutton 1 is pressed');
gettext('Send '1' when the  \nbutton 2 is pressed');
gettext('putc-bit-05-two-buttons2');
gettext('# PUTC-BIT-stdout: Example 5\n\nThe state of both buttons is printed on the console   \n4 times per second  \nThe bits are sent in pairs. When the tic from the heart  \nreaches the first putc-bit module, it sends the button  \n1 state to the stdout bus (it passes through the second  \nputc-bit module as it is OFF (transparent mode))  \n\nWhen it finish, a tic is emited on the done signal that  \nis connected to the txmit input of the second module, allowing  \nit to send the state of the button 2 to the serial port  \n\n');
gettext('Button 2 state');
gettext('Button 1 state');
gettext('When module 1 is  \nfinished, module 2  \nis started');
gettext('**Module 1**');
gettext('**Module 2**');
gettext('putc-bit-06-AND-test');
gettext('# PUTC-BIT-STDOUT: Example 6\n\nShow the inputs (A,B) and output (C) of the AND gate on the console  \nThe Serial output done is connected to next label and should be connected to  \nthe next input of the three Putc-bit blocks\n\nThere are three putc-bit blocks: The first one is for printing the A signal,  \nthe second for the B signal and the third for the C signal\n\nThe module 1 is activated 4 times per second (4Hz). When it is done, the module 2  \nis activated, and then the third ');
gettext('**Module 3**');
gettext('Sample the main circuit  \n4 times per second');
gettext('**Main circuit**: an AND gate controlled by  \ntwo buttons');
gettext('This module sends the \"F\" and  \n\"T\" character instead of 0/1');
gettext('putc-bit-07-AND-test2');
gettext('# PUTC-BIT-STDOUT: Example 7\n\nExample of use of the **STDOUT BUS**  \nIt is the same than example 6, but the signals A,B and C  \nare printed on the console only when there is a change in  \nA or B\n');
gettext('**Main circuit**  ');
gettext('Changes in A and B signals');
gettext('Print the initial state');
gettext('putc-char-01');
gettext('Código ASCII del carácter A');
gettext('Corazón de bombeo de tics a con periodo paramétrico de segundos');
gettext('# PUTC-CHAR: Example 1\n\nExample of use of the putc-char block  \nThe 'A' character is sent every second\n');
gettext('putc-char-02');
gettext('# PUTC-CHAR: Example 2\n\nExample of chaining the putc-char block with the  \nputc-bit block. The state of the button 1 is  \nprinted on the console every 100ms\n\nFirst the state is printed, followed by a New line\n');
gettext('**Module 2**  \nNew line  ');
gettext('**Module 1**  \nPrinting the button  \nstate');
gettext('putc-char-03');
gettext('# PUTC-CHAR: Example 3\n\nMonitoring a NOT gate: The state of the input and  \noutput are sent throug the serial port every 100ms');
gettext('**Module 3**  ');
gettext('**Module 1**  ');
gettext('**Module 2**  ');
gettext('Print the output  \nas a T or F character');
gettext('Print the Input  \nas '0' or '1' characters');
gettext('Print a new line \n(\\n)');
gettext('Every 100ms the module 1 is started  \nfor printing the input (A). When  \nit is finished, the module 2 is  \nstarted for printing the output (B)  \nand finally the module for printing  \nthe new line character  ');
gettext('putc-char-04');
gettext('# PUTC-CHAR: Example 4\n\nMonitoring a NOT gate: The state of the input and  \noutput are sent throug the serial port whenever  \nthere is a change in its input (also after the reset)  ');
gettext('Where there is a change in the input  \nthe module 1 is started for printing  \nthe input (A). When it is finished,  \nthe module 2 is started for printing  \nthe output (B) and finally the module  \nfor printing the new line character  ');
gettext('There is change in the  \nbutton state  ');
gettext('Initial tic after  \nreset');
gettext('Print the signals  \nif there is a changed  \nin the input or after  \na reset');
gettext('Show the current  \noutput in the LED');
gettext('putc-char-05');
gettext('# PUTC-CHAR: Example 5\n\nExample of use of two putc-char blocks in a chain  \nThe 'A' character is sent every second  \nWhen the button is pressed, the character '*'  \nis sent\n');
gettext('putc-char-06');
gettext('# PUTC-CHAR: Example 6\n\nExample of chaining the putc-char block with the  \nputc-bit block. The state of the button 1 is  \nprinted on the console every 100ms\n\nFirst the state is printed, followed by a New line\n\n');
gettext('**Print(\"\\n\")**');
gettext('**Print the button**  \n**state as a character**  ');
gettext('putc-char-07');
gettext('Código ASCII del carácter J');
gettext('# PUTC-CHAR: Example 7\n\nExample of chaining two putc-char blocks  \nWhen idle, the Character * is printed on the  \nconsole every 2 seconds. If the SW1 is pressed,  \nthe A character is printed. If the SW is pressed,  \nand J character is printed followed by an 'A'\n');
gettext('The char * is printed on the  \nconsole every 2 seconds');
gettext('When the SW2 button is pressed  \nthe J Char is sent, and when it is  \ndone, the A is sent by module 2');
gettext('If the SW1 button is pressed, an  \nA character is sent');
gettext('The A character is also sent  \nwhen the module 1 it is done');
gettext('Create the stdout bus by  \nadding data and tic to rdy');
gettext('putc-char-08');
gettext('# PUTC-CHAR: Example 8\n\nExample of monitoring a NOT Gate. It has only one input (A)  \nand one output (S). This both signals are printed on the  \nconsole every 100ms\n\nExample of what is printed on the console:\n\n```\nA0S1\nA0S1\nA1S0\nA0S1\n...\n```');
gettext('**Print bit S**');
gettext('**Print(\"S\")**');
gettext('**Print bit A**');
gettext('**Print(\"A\")**');
gettext('**Module 4**');
gettext('**Module 5**');
gettext('The module 1 is activated every 100ms  \nAs all the modules are chained, when the  \ni module is done, the i+1 module is started   \n');
gettext('### Circuit to monitorize');
gettext('Syntax-char-toggle-led');
gettext('### Example\n\n```\n>t\n1\nOK!\n>t\n0\nOK!\n>hd\nUnknown command\n>\n```');
gettext('## Unkwnon command output');
gettext('stdout-LEDx8-test-01');
gettext('# STDOUT-LEDx8: Example 1\n\nTesting the LEDx8 stdout device  \n\nSend the bits 1 and 0 to the STDOUT bus, where the  \n8-device LEDs is connected');
gettext('Bit 1');
gettext('Bit 2');
gettext('**STDOUT** BUS  ');
gettext('**Print Bit 1**');
gettext('**Print Bit 0**');
gettext('It only takes one cycle  \nto process the character');
gettext('stdout-LEDx8-test-02');
gettext('# STDOUT-LEDx8: Example 2\n\nTesting two output devices connected to the  \nSTDOUT BUS\n\nThe bits 0 and 1 are sent when the buttons 0 and 1 are  \npressed respectively.  They are printed on both devices:  \nThe serial console and the LEDs');
gettext('**OUTPUT DEVICE 1:** LEDS  ');
gettext('**OUTPUT DEVICE 2:** SERIAL  ');
gettext('**IMPORTANT**  \n\nONLY one rdy signal should be inserted  \non the STDOUT BUS: It should be the signal  \nfrom the slowest device (in this case  \nthe serial console is slower)\n');
gettext('stdout-LEDx8-test-03');
gettext('# STDOUT-LEDx8: Example 3\n\nThe state of the buttons 1 and 2 is printed on two consoles  \nat the same time: the LEDs and the Serial port  \nThey are only printed whenever there is a change in any  \nof the buttons');
gettext('**Button 1 state**');
gettext('**Button 2 state**');
gettext('Move the cursor 2  \ncharacters back');
gettext('stdout-LEDx8-test-04');
gettext('**STDIN BUS**  ');
gettext('**STDOUT BUS**  ');
gettext('# STDOUT-LEDx8: Example 4\n\nCombination of the output LED8 device with an input device  \nThe keyboard is used for introducing 1s and 0s  \nThe are printed on the current cursor position in the LEDs  \nIf the backspace key is pressed, the cursor is moved back one  \ncharacter.  When ENTER is pressed a new line can be entered\n');
gettext('The same output is shown in  \ntwo group of LEDs');
gettext('Board LEDs');
gettext('External LEDs');
gettext('stdout-LEDx8-test-05');
gettext('# STDOUT-LEDx8: Example 5\n\nExample of combining 4 i/o devices: two inputs and two outputs\n\nTwo input devices are combined into one STDIN:  \nThe serial input and the keyboard  \nAll the characters inputed are written on both  \noutput devices: serial and LEDs\n');
