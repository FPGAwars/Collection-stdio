// Translation document for the collection
// =======================================
// This file contains the texts
// annotated for translation
//
// Instructions:
// 1. Open the PO file with Poedit
// 2. Press "Update" to update from sources

gettext('Bus');
gettext('Debug');
gettext('Device');
gettext('Others');
gettext('stdin');
gettext('stdout');
gettext('stdin-stdout-adaptor-2');
gettext('Adapter between the stdin and stdout buses. Type 2');
gettext('stdin bus splitter into data and tic signals');
gettext('The data + tic signal are added into the stdout bus)');
gettext('stdin-stdout-adaptor');
gettext('Adapter between the stdin and stdout buses');
gettext('stdout bus joiner (data + tic)');
gettext('stdin-enable');
gettext('Componente genérico');
gettext('Puerta AND');
gettext('stdin bus joiner (data + tic)');
gettext('## STDIN stream enable');
gettext('stdin-joiner');
gettext('stdin-mixer');
gettext('STDIN mixer. Combine two stdin buses into one');
gettext('RS-FF-set-verilog. RS Flip-flop with priority set. Implementation in verilog');
gettext('System - D Flip-flop. Capture data every system clock cycle. Verilog implementation');
gettext('2-to-1 Multplexer (9-bit channels). Verilog implementation');
gettext('**STDIN BUS 0**');
gettext('**STDIN BUS 1**');
gettext('Default input bus');
gettext('Active stdin channel');
gettext('By default, the channel 0 is selected  \nDepending on the tic received, one  \nchannel or another is selected');
gettext('The tics are delayed one cycle  \nThe fist cycle is used for selecting the  \noutput channel, the next cycle cotaints the  \nactual tic');
gettext('## STDIN-Auto-Selector\n\nIt combines automatically two input STDIN buses  \nWhenever a data is received on one of the buses,  \nit is outputed into one single STDIN bus');
gettext('Parameter: Initial value');
gettext('System clock');
gettext('Input data');
gettext('Output');
gettext('# D Flip-Flop  (system)\n\nIt stores the input data that arrives at cycle n  \nIts output is shown in the cycle n+1');
gettext('Not connected');
gettext('stdin-spliter');
gettext('adder-data-tic');
gettext('joiner-2-data-tic');
gettext('next-in');
gettext('Convert the 1-bit next signal into a 10-bit stdout bus');
gettext('next-out');
gettext('Extract the next signal from the stdout bus');
gettext('spliter-2-data-tic');
gettext('stdout bus splitter into data and tic signals');
gettext('Memory');
gettext('Hterm-toggle');
gettext('Un bit constante a 0');
gettext('Puerta OR de 3 entradas');
gettext('Puerta OR');
gettext('start: Start signal: It goes from 1 to 0 when the system clock starts. 1 cycle pulse witch. Block implementation');
gettext('Constant bit 0');
gettext('Lectura de caracteres de entrada a traves de entrada serie');
gettext('Receptor serie asíncrono. Velocidad por defecto: 115200 baudios');
gettext('Print a constant string of 63 or less characters');
gettext('Comparador de un operando de 8 bits. Se compara si el operando es igual al parámetro');
gettext('Un bit constante a 1');
gettext('Puerta NOT');
gettext('8bits constant value: 0');
gettext('Generic: 8-bits generic constant (0-255)');
gettext('Máquina de contar, de 6 bits, con entrada de stop');
gettext('6-bits adder. One operand is a constant (no carry)');
gettext('two operand 6-bits comparator');
gettext('Valor genérico constante (menos 1), de 6 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Biestable de almacenamiento del estado de la máquina');
gettext('Rising-edge detector. It generates a 1-period pulse (tic) when a rising edge is detected on the input. Block implementation');
gettext('NOT gate (Verilog implementation)');
gettext('Two bits input And gate');
gettext('Falling-edge detector. It generates a 1-period pulse (tic) when a falling edge is detected on the input');
gettext('06-Reg-rst: 6 bits Register with reset. Verilog implementation');
gettext('64-bytes memory, initilized with a string');
gettext('2-to-1 Multplexer (10-bit channels). Verilog implementation');
gettext('Print a constant string of 7 or less characters');
gettext('Máquina de contar, de 3 bits, con stop');
gettext('Comparador de dos operandos de 3 bits');
gettext('Valor genérico constante (menos 1), de 3 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Sumador de un operando de 3 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('03-Reg-rst: 3 bits Register with reset. Verilog implementation');
gettext('8-bytes memory, initilized with a string');
gettext('Input 2 chars in edit mode');
gettext('Comparador de igualdad, de un operando de 2 bits');
gettext('Filter of printable chars, in addition to enter and del');
gettext('8 bits greather or equal comparator');
gettext('8 bits less or equal than comparator');
gettext('Valor genérico constante, de 9 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('2bits-Greather or equal than comparator');
gettext('Print a constant string of 3 or less characters');
gettext('Máquina de contar, de 2 bits (cuenta hasta 4 ciclos)');
gettext('Sumador de un operando de 2 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 2 bits');
gettext('Valor genérico constante (menos 1), de 2 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('02-Reg-rst: 2 bits Register with reset. Verilog implementation');
gettext('4-bytes memory, initilized with a string');
gettext('4Bytes buffer with dump');
gettext('Multiplexor de 2 a 1');
gettext('2bits up-down counter with limits. Reset');
gettext('Comparador menor que, de un operando de 2 bits');
gettext('2bits-Greather than comparator');
gettext('Codificador de 2 a 1. La salida zero se activa cuando ninguna entrada está activada');
gettext('2-to-1 Multplexer (2-bit channels). Verilog implementation');
gettext('4 Bytes Synchronous memory');
gettext('2-to-1 Multplexer (8-bit channels). Verilog implementation');
gettext('8bits ASCII new line');
gettext('Máquina de contar, de 1 bit, con entrada de Stop');
gettext('Demultiplexor de 1 bit, de 1 a 2');
gettext('TFF-rst-verilog: TFF with toggle input and reset: It toogles on every system cycle if the input is active. Verilog implementation');
gettext('Transmit one character to the STDOUT bus');
gettext('Print a bit plus a new line');
gettext(' Transmit one bit as a character. STDOUT-bus');
gettext('Valor genérico constante, de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Print a constant string of 31 or less characters');
gettext('32-bytes memory, initilized with a string');
gettext('Máquina de contar, de 5 bits, con entrada de stop');
gettext('5-bits adder. One operand is a constant (no carry)');
gettext('two operand 5-bits comparator');
gettext('Valor genérico constante (menos 1), de 5 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('05-Reg-rst: 5 bits Register with reset. Verilog implementation');
gettext('Print a constant string of 127 or less characters');
gettext('Máquina de contar, de 7 bits, con entrada de stop');
gettext('7-bits adder. One operand is a constant (no carry)');
gettext('two operand 7-bits comparator');
gettext('Valor genérico constante (menos 1), de 7 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('07-Reg-rst: 7 bits Register with reset. Verilog implementation');
gettext('128-bytes memory, initilized with a string');
gettext('Serial transmiter for the stdout bus, with sysclk parameter');
gettext('Serial transmitter with system clock freq parameter');
gettext('char syntax block');
gettext('Detect if the command is valid');
gettext('RS-FF-set. RS Flip-flop with priority set. Block implementation');
gettext('Constant bit 1');
gettext('2-to-1 Multplexer (1-bit channels). Verilog implementation');
gettext('TFF-verilog. System TFF with toggle input: It toogles on every system cycle if the input is active. Verilog implementation');
gettext('**Init**');
gettext('Print the prompt');
gettext('**STDIN BUS**');
gettext('The InputLN-Charx2 component:\n\nIt waits for the user to enter the  \ncomand and pressing enter');
gettext('**STDOUT**');
gettext('### Blank command\n\nThe user has just press the  \nenter key without typibng anything');
gettext('### Toggle command\n');
gettext('State of the  \ncommands');
gettext('The command is  \nnot known');
gettext('### Unknown command\n');
gettext('A new command is  \navailable');
gettext('Dump the next  \nbyte in the next  \ncycle');
gettext('### Toggle the LED\n');
gettext('LED state');
gettext('## Toggle button OUTPUT');
gettext('Print the LED  \nstate');
gettext('Previous command  \nis finished!');
gettext('Reset the  \ncommand detectors');
gettext('After the enter is pressed  \nthe dump is started');
gettext('Initial value: 1');
gettext('Initial value: 0');
gettext('Falling edge');
gettext('## STDIN serial\n\nSerial receiver for the STDIN bus\n');
gettext('**STDIN Bus**  \n* Data received (8 bits)  \n* tic (1 bit)');
gettext('## PRINT: Transmit one character (STDOUT bus)\n\nWhen **idle**, the STDOUT bus crosses the component without modification     \n\nWhen the machine starts, the first chars outputed and the state is changed to busy  \nWhen the transmitter is done (tic received in next)  the machine is turned off');
gettext('Start tic: The transmision of  \nthe bytes is started');
gettext('Transmit the next  \ncharacter from the string');
gettext('Tic output: Execute!');
gettext('The machine has finished');
gettext('Count machine. It is counting  \nuntil the stop signal is  \nactivated');
gettext('If the character read is 0  \nwe have reached the end of  \nthe string');
gettext('Memory with the string  \nto be transmited');
gettext('**STDOUT BUS**');
gettext('Transparent mode...  \nor not');
gettext('**Reloj del sistema**');
gettext('**Estado de**  \n**la máquina**');
gettext('Máquina encendida');
gettext('Máquina apagada  \n(rst = 1)');
gettext('Tic de arranque');
gettext('Tic de fin');
gettext('**Contador de ciclos**');
gettext('Número de ciclos  \ncontados');
gettext('Valor  \nincrementado');
gettext('### Salidas');
gettext('Estado de la máquina');
gettext('Ciclo actual');
gettext('Cuenta finalizada');
gettext('Ejecutar el ciclo');
gettext('Número de ciclos  \na contar');
gettext('¿Estamos en el  \nciclo k-1?');
gettext('Solo se hace caso a la  \nentrada next si la  \nmáquina está encendida');
gettext('Nuevo ciclo');
gettext('Si es el ciclo k-1 y  \nse pide un ciclo  \nnuevo: Terminar');
gettext('Apagar la  \nmáquina');
gettext('Ciclo nuevo:  \nincrementar la cuenta');
gettext('El tic de start se saca  \npor exec para que se ejecute  \nel primer ciclo');
gettext('Si la máquina está  \napagada, las señales  \nde ejecución no pueden  \nsalir!');
gettext('Retrasar la señal un ciclo  \nmientras que se detecta si  \nla máquina ha finalizado o no');
gettext('Apagado automática,  \ncuando la máquina  \ntermina');
gettext('Apagado manual');
gettext('**Tic de apagado**');
gettext('**Tic de encendido**');
gettext('**Inicializar**');
gettext('**Estado de la máquina**');
gettext('## Rising edge detector\n\nIt generates a 1-period pulse (tic) when a rising edge is detected on the  \ninput signal');
gettext('Input signal');
gettext('Current signal  \nstate');
gettext('Signal state in the previous  \nclock cycle');
gettext('If the current signal is 1 and its value in  \nthe previous clock cycle was 0, it means  \nthat a rising edge has been detected!  \nThe output es 1\n\nIn any other case the output is 0');
gettext('**Delay**: 0 clock cycles \n\nThere is no delay between the arrival of a rising edge  \nand its detection');
gettext('Input');
gettext('## Falling edge detector\n\nIt generates a 1-period pulse (tic) when a falling edge is detected on the  \ninput signal');
gettext('If the current signal is 0 and its value in  \nthe previous clock cycle was 1, it means  \nthat a falling edge has been detected!  \nThe output es 1\n\nIn any other case the output is 0');
gettext('**Delay**: 0 clock cycles \n\nThere is no delay between the arrival of a falling edge  \nand its detection');
gettext('Para automático de la  \nmáquina cuando ha terminado  ');
gettext('Paro externo');
gettext('Empty Buffer condition  \nThere are 0 chars in the buffer');
gettext('The STDIN input stream is enable only if  \nthe machine in on and it is in edit mode');
gettext('The machine is on');
gettext('Edit model on');
gettext('Only printable chars  \nare allowd');
gettext('Enter key detected');
gettext('Delete key pressed');
gettext('The Delete key is only valid  \nif the buffer is not empty');
gettext('If the buffer is full,  \nno more chars are allowed');
gettext('Only chars when the buffer  \nis not full');
gettext('Echo the received characteres  \nto the STDOUT STREAM');
gettext('Characters sent to the STDOUT  \nstream when the delete key is presed');
gettext('Delete key received  ');
gettext('When the machine is on,  \nthe STDOUT stream is  \nused by the block');
gettext('Number of characteres  \nin de Buffer (Debug)');
gettext('**Start the machine**');
gettext('Stop the machine  \n(Abort)');
gettext('It only works if  \nthe machine is active');
gettext('### Machines stages  \n* Stage 0:  Edit mode  \n* Stage 1:  Dump mode');
gettext('Machine stage');
gettext('The machine is done');
gettext('If in edit mode and the enter  \nkey is pressed: change to  the  \nnext stage');
gettext('If in dump mode and the dumping  \nis finished, change to the next  \nstage: done');
gettext('Insert the character  \nin the buffer. Also the  \nenter key (\\n)');
gettext('If the enter key is pressed  \nthe \\n character is inserted  \nif not, the received char');
gettext('Start the dumping of the  \nbuffer');
gettext('Proceed with the Next  \nchar to dump');
gettext('When the machine is off,  \nthe stdin bus is in  \ntransparent mode');
gettext('Number of characters  \nin the buffer');
gettext('Character dumped  \nfrom the buffer');
gettext('full Buffer condition  \nThere are 2 or more chars  \nin the buffer');
gettext('## InputLn-charx2  \nWaits for the user to enter a 2 characters command  \nThe user can use the Delete key  \nThe command is outputed when the enter key is pressed  ');
gettext('Only characteres in this  \nrange are valid: [32, 126]  \nThe others are ignored');
gettext('## STINFilter: Printable\n\nThe STDIn stream is filtered. Ontly printable  \ncharacteres are allowed on the STDIN-out stream\n\nCommands for the Enter (/n) and Delete are generated  \n(but that characteres are not sent to stdin output stream)');
gettext('**TOP registers**  \nIt contais the address where  \nthe next byte will be stored');
gettext('Number of caracters  \nin the buffer');
gettext('Insert one byte  \nin the buffer');
gettext('Change in the  \nTOP reggister');
gettext('Byte to store in the buffer');
gettext('Remove the last bytes');
gettext('Start the Dumping of  \nthe buffer');
gettext('Dump the next byte');
gettext('**DUMP machine**');
gettext('In Dumping mode');
gettext('Dump addr');
gettext('Dump finished');
gettext('Condition:  \nCurrent dump addr is  \nequal to the top register?');
gettext('**YES**: The dump is finished!');
gettext('**NO**: Continue  \ndumping the memory');
gettext('Propagate the data_tic in  \nthe dump mode');
gettext('It is synchronized  \nwith the data from memory  \n(should be delayed 1 cycle)');
gettext('Memory for storing  \nthe bytes inserted');
gettext('Select the addr for  \naccesing the memory,  \naddr: If in dumping mode  \ntop: If inserting bytes');
gettext('Data to insert  \ninto the memory');
gettext('Select the accesing mode  \nfor the memory:  \n0: Reading in dumping mode  \n1: Writing in insert mode');
gettext('Data read from the  \nmemory when in dump  \nmode');
gettext('Tic: change in the buffer');
gettext('Data from the buffer');
gettext('Dumping finished!');
gettext('In dumping mode');
gettext('# 4BYTES BUFFER  \n\nBuffer for storing 4 byts, although only 3 can be used (the 4th is  \nused for indicating the buffer is full)  \n\nThe buffer has 3 operations:  \n* insert:  Storing the byte in the last posiition  \n* delete:  Delete the last byte  \n* dump: Dunmp the memory contents, from the first  \n  byte to the last one\n  The dump operation is done by a machine. It needs to  \n  receive the next signal to proceed for dumping the  \n  next value');
gettext('Maximum value');
gettext('Minimum value');
gettext('**Increment tic**  \nup button press and  \ncurrent value < Max');
gettext('**Decrement tic**  \nDown button pressed and  \ncurrent value > Min');
gettext('inc tic: 1  \ndec tic: 0\n');
gettext('Action detected!  \nEither inc or dec');
gettext('The counter  \nhas changed!');
gettext('Current value');
gettext('Value incremented!');
gettext('Value decremented!');
gettext('## Up-down counter with MAX and MIN limits\n\nThe counter is incremented when the up tic is received  \nand it has not already reached its maximum value  \n\nThe counter is decremented then the down tic is received  \nand it is not in its minimum value');
gettext('¿Estamos en el  \nciclo 1?');
gettext('Si es el ciclo 1 y  \nse pide un ciclo  \nnuevo: Terminar');
gettext('Type of stop:  \n0: Internal (done)  \n1: External (abort)');
gettext('## PUTC: Transmit one character (STDOUT bus)\n\nWhen **idle**, the STDOUT bus crosses the component without modification    \n\nWhen the machine starts, the char is outputed and the state is changed to busy  \nWhen the transmitter is done (tic received in next)  the machine is turned off');
gettext('Start tic: The byte from the  \ninput char is transmited');
gettext('Char to be transmited');
gettext('State of the machine:  \n1: ON: transmitting  \n2: OFF: transparent mode  ');
gettext('If the machine is on  \nand the character has been  \ntransmitted: Turn it off');
gettext('**Create the bus**  \nfrom the data and tic signals');
gettext('## PrintLn-bit: Print one bit plus a new line character  \n');
gettext('Bit to be transmited');
gettext('Transmit now! (tic)  \nActivate the machine');
gettext('**Block 1**  \nPrint the bit (0,1)');
gettext('The machine is busy either  \nthe block 1 is busy or  \nthe block 2 is busy');
gettext('**Block 2**  \nPrint new line char');
gettext('## PUTC-bit-stdout: Transmit one bit (STDOUT bus)  \n\nWhen activated, the bit input is sent as the character '0' or '1'  \nWhen not active, the stdout crossed the block (transparent mode)');
gettext('The bit to be transmitted should be  \nsyncronized with its transmit tic');
gettext('If the machine is ready and  \nthe next tic is received:  \nwe are done');
gettext('Machine is on: send a character');
gettext('State of the machine  \n0: OFF  \n1: ON: Sending one character');
gettext('Character to transmit when  \nthe input bit is 1');
gettext('Character to transmit when  \nthe input bit is 0');
gettext('Select with character to transmit  \naccording to the input bit');
gettext('## STDOUT serial\n\nSerial transmitter for the STDOUT bus\n');
gettext('**STDOUT Bus**  \n* Data to transmit (8 bits)  \n* tic (1 bit)\n* data sent (done tic, 1 bit)');
gettext('## Syntax Char  \n\nSyntax block for receiving a specific character  \n\nWhen the character recived is what the block is expecting,  \nit gets activated, and the blocks becomes into a wire (transparent mode)  \nuntil it is reset\n\nIf the first received character is different from what it was expecting,  \nthen block blocks. it disconnect itself from the input until it is reset');
gettext('**Reset the block**');
gettext('**Input character**');
gettext('**Active state**  \n0: Block is not active  \n1: In Active mode');
gettext('Depending on the mode, the tic  \nreceived is outputed (transparent mode)\nor sent inside the block for further processing\n');
gettext('Transparent mode');
gettext('Ignored');
gettext('If the block is blocked, the tic  \nis ignored. Else the tic is sent  \nto the next stage for further processing');
gettext('**Expected character**');
gettext('State of the received character  \n0: Not the one was expected   \n1: The one that was expected  ');
gettext('Expected character  \nreceived: Change to   \nactive mode');
gettext('Other character received:  \nBlock the component');
gettext('**Block state**  \n0: Not blocked\n1: Blocked');
gettext('Any command detected?');
gettext('End of command \ndetected');
gettext('No other cmds  \ndetected');
gettext('Unknown cmd  \ndetected');
gettext('Valid command detected  \nReset the error flip-flop');
gettext('## Syntax ELSE  \n \nDetect if the command is valid based on the state  \nof the commands detected. If no command has been  \ndetected when the /n char is received -->  \nit is an invalid command');
gettext('Commands state:  \n0: None of the commands  \n   have been detected  \n1: Valid command detected');
gettext('Priority for the set');
gettext('Print-str');
gettext('Serial print-str');
gettext('Print a constant string of 15 or less characters');
gettext('Máquina de contar, de 4 bits, con entrada de stop');
gettext('Sumador de un operando de 4 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 4 bits');
gettext('Valor genérico constante (menos 1), de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('04-Reg-rst: 4 bits Register with reset. Verilog implementation');
gettext('16-bytes memory, initilized with a string');
gettext('PrintLn-Bin16');
gettext('Debug: Print a 16bits number in binary');
gettext('Print a 16-bits number in Binary');
gettext('Máquina de contar, de 4 bits');
gettext('16-SL-ld: 16 bits shift left register with load. Verilog implementation');
gettext('Transmit one constant character to the STDOUT bus');
gettext('First the MSB is  \nprinter');
gettext('state machine  \n');
gettext('Print the current  \nbit');
gettext('Store the nunmber  \nto print');
gettext('Number to print');
gettext('## Print-bin-16-bits: Transmit one 16-bits number in Binary\n\nWhen activated, the 16-bits number is sent as three binary  \ncharacters (0/1)');
gettext('## PUTC: Transmit one constant character ');
gettext('PrintLn-Char');
gettext('Serial debugger for characters. It prints the character + a line feed');
gettext(' Print a character + a new line');
gettext('## Debugger-PrintLn-char\n\nPrint a char on the console, followed by a new  \nline character');
gettext('2-bit number to print  \n(base-4. Simbols: 0,1,2 and 3)  ');
gettext('Tic for printing');
gettext('**Serial transmitter**');
gettext('Print the current  \nBase 4 number');
gettext('Insert the done signal  \nin the stdout BUS');
gettext('## PRINTLN-char: Char + \\n  \n\nWhen activated, the char + a new line are sent');
gettext('Print the char');
gettext('PrintLn-Hex8-sysclk');
gettext('Print an 8-bits number in hexadecimal. Sysclk param');
gettext('Print a byte in hexadecimal numbers');
gettext('Separador de bus de 8-bits en buses de 4 bits');
gettext('Mach-count-1-bit: 1-bit count machine');
gettext('OR2: Two bits input OR gate');
gettext('1-to-2 DeMultplexer (1-bit channels)');
gettext('08-Reg: 8 bits Register. Verilog implementation');
gettext('Transmit a 4-bits hex number (characteres 0 - 9, a - f)');
gettext('Circuito combinacional de 4 entradas y 8 salidas');
gettext('Separador de bus de 4-bits en 4 cables');
gettext('Agregador de 2 buses de 4-bits a bus de 8-bits');
gettext('Agregador de 4 cables en un bus de 4-bits');
gettext('Valor genérico constante, de 1 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Comparador menor que, de un operando de 4 bits');
gettext('2-to-1 Multplexer (4-bit channels). Verilog implementation');
gettext('First the MSB is  \nprinter, then the LSB');
gettext('Bit to print:  \n0: Bit 0  \n1: Bit 1');
gettext('2-state machine  \nTwo operation are needed');
gettext('Print the current  \nhex digit');
gettext('## PUTC-base4-bin: Transmit one base-4 number in Binary\n\nWhen activated, the base-4 number is sent as two binary  \ncharacters (0/1)');
gettext('If the machine is active, no more start signals  \nare allowed to enter');
gettext('Execution tic:  \n* One tic per state');
gettext('1-bit counter');
gettext('1-to-2 Demux');
gettext('Turn off  \nthe machine');
gettext('n=1');
gettext('n=0');
gettext('The next signal can only go inside the machine  \nif it is busy');
gettext('The machine is busy from the very  \nbegining in which the start_ok  \nsignal arrives');
gettext('Initial state cycle  \n(n = 0)');
gettext('When the next_ok signal is received  \nthe initial cycles is finished');
gettext('When the next_ok is received the counter is  \nincreased');
gettext('The machine is active: either in the first  \nstate cycle (n=0) or the next cycles (n=1)');
gettext('Wait one cycle for the  \ncounter to be updated');
gettext('The next_ok signal output either as the  \nexec signal (when n=1) or as the done signal  \nwhen (n = 0)');
gettext('Then count machine has three states:  \n\n* Idle: The machine is off, waiting to receive the start signal  \n* n = 0: Initial state cycle. It goes from receiveing the start signal until  \n  the first next signal arrives\n* n = 1: second state cycle. Fron the first next signal to the second');
gettext('## PUTC: Transmit 4bits as an hexadecimal digit (STDOUT bus)\n');
gettext('Write the digits (a-f) in  \nuppercase by default');
gettext('Condition: is the number  \nreceived between 10 and 15?  \n(a to f digit?)');
gettext('The digits a-f are changed to uppercase  \nby setting the 5th bit to 0 or 1');
gettext('PrintLn-OK');
gettext('Print the OK message');
gettext('Print the OK + new line string');
gettext('## Debugger-PrintLn-OK\n\nPrint the OK message');
gettext('The machine is done  \nwhen the block  \nis done');
gettext('## PRINTLN-OK: Print the OK + new line string\n');
gettext('PrintLn-Uint8-sysclk');
gettext('Print an 8-bits unsigned number in decimal. Sysclk param');
gettext('Print an 8-bits unsigned integer (0 - 255)');
gettext('Comparador de un operando de 4 bits. Se compara si el operando es igual al parámetro');
gettext('Multiplexor de 4 a 1 de 4 bits');
gettext('Valor constante 0 para bus de 4 bits');
gettext('Valor genérico constante, de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Máuina de conversion Binario - BCD de 8 bits');
gettext('04-Reg: 4 bits Register. Verilog implementation');
gettext('08-SL-ld: 8 bits shift left register with load. Verilog implementation');
gettext('Cálculo combinacional parcial para la conversion de Binario a BCD');
gettext('SL1-4-verilog: Shift  a 4-bit value one bit left. LSB is filled with 'in' and the MSB is written to out . Verilog implementation');
gettext('Print the current  \ndigit');
gettext('## Print-uint8: Print a 8-bits unsigned integer (0 - 15)\n\n');
gettext('3 stages machine:  \n* stage=0: print the MS digit\n* stage=1: print the next digit\n* stage=2: print tje LS digit');
gettext('Fixed size number:  \nSelect if the number is printing  \nalways with the same number of  \ndigits or the left zeros are removed\n\n* FSize = 0: Zeros at the left are Not printed  \n* SIZE2 = 1: Print all the digits always');
gettext('Select the digit  \nto print');
gettext('Non-zero digit  \ndetected');
gettext('Any of the previous digits  \nwas non-zero');
gettext('Clear the flag  \nin the begining');
gettext('The flag is set to 1  \nwhen the count machine  \nis on and a not zero  \ndigit is detected');
gettext('Capture the number to  \nprint, in the begining');
gettext('Start the conversion');
gettext('Start the count machine for  \nprinting the digits!');
gettext('Current digit to  \nprint');
gettext('Current digit is  \nNOT 0');
gettext('Decide if the current digit is  \nprinted or not!');
gettext('Print the digit!');
gettext('Don't print the digit!');
gettext('Condition for printing  \nthe current digit');
gettext('The LS digit is  \nALWAYS printed!');
gettext('If FSize constant is  \nset, the digit are  \nprinted ALWAYS');
gettext('If FSIze constant is NOT  \nset the digit is printed  \neither if it is not zero  \nor a previous digit was not zero');
gettext('**Reloj**');
gettext('**Número a convertir**');
gettext('**Arranque**');
gettext('Estado de la  \nmáquina');
gettext('Dígito 0');
gettext('Dígito 1');
gettext('**Máquina de contar**  \nLa conversión se realiza en  \n4 iteraciones');
gettext('Cargar el numero a convertir  \nen el arranque de la máquina');
gettext('Actualizar registro  \nen cada etapa');
gettext('**Calculos para el digito 0**');
gettext('**Calculos para el digito 1**');
gettext('Dígito 2');
gettext('Esta céluca combinacional realiza una parte del cálculo del  \nalgoritmo para convertir de **binario a BCD**:\n\nSi la entrada a es mayor o igual a 5, se devuelve a+5,  \nde lo contrario se devuelve a (se deja como estaba)');
gettext('¿Es a >= 5?');
gettext('**Si**  \na es >= que 5');
gettext('Calcular a+3');
gettext('**No**  \na NO es >= 5');
gettext('PrintLn-base-4');
gettext('Serial debugger for base 4 numbers (2-bits). It prints the number + a line feed');
gettext(' Transmit a 2-bits number as a character + a new line');
gettext(' Transmit two bits as a base-4 character (0-3)');
gettext('Agregador de 2 buses de 6 y 2-bits a bus de 8-bits');
gettext('Valor genérico constante, de 6 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('## Debugger-PrintLn-base-4\n\nPrint a 2-bit number on the console, followed by a new  \nline character');
gettext('## PRINTLN-base4-stdout: Transmit one bit (STDOUT bus)  \n\nWhen activated, the bit + a new line are sentd');
gettext('## PUTC-base4: Transmit one base-4 number \n\nWhen activated, the base-4 number is sent as a character (0-3)  \nIf not activated, the stdout bus is in transparent mode');
gettext('PrintLn-bit');
gettext('Serial Debugger for printing one bit + new line');
gettext('## Debugger-PrintLn-Bit\n\nPrint a bit on the console, followed by a new  \nline character');
gettext('hterm-bit-stdout');
gettext('Hardware terminal with only two commands: 0 and 1');
gettext('Read one bit from the input console, with edition (delete). Finish when enter is pressed');
gettext('Detector de flanco de subida. Emite un tic cuando detecta un flanco ascendente');
gettext('When activated, it waits for a bit to be received codified in the '0' and '1' symbols by default. The received character is echoed (if valid)');
gettext('When activated, it waits for a bit to be received codified in the '0' and '1' symbols by default');
gettext('Detect one bit');
gettext('DFF. D Flip-flop. Verilog implementation');
gettext('Get a constant character');
gettext('Print the Initial message');
gettext('**MAIN**');
gettext('Blank command');
gettext('Input the digits!');
gettext('## HTerm-bit-stdout\n\nHardware terminal with two commands: 0, 1 and blank  \nOther stdout blocks can be used');
gettext('## INPUTLN-BIT-ECHO  \n');
gettext('State of the machine');
gettext('Received bit');
gettext('Blank cmd');
gettext('Select machine or  \ntransparent channel');
gettext('Wait for the '0' or '1' characters');
gettext('Machine state:');
gettext('The machine stops  \nwhen the user press  \nENTER or an abort cmd  \narrives');
gettext('Send the string for deleting  \nthe previous digit');
gettext('**BUFFER**  \nfor 1 bit');
gettext('**Buffer state:**  \n0: empty  \n1: Full  ');
gettext(' When a digit is  \n received the buffer  \n is full');
gettext('If the BS key is  \nreceived the buffer is  \nempty');
gettext('When the machine is  \nOFF the buffer is empty');
gettext('The input starts when  \nthe machine is turned on');
gettext('If a valid BS is received,  \nthe inputs is started');
gettext('The input is stoped when  \nthe machine is off');
gettext('Waits for the BS character  \nto be received');
gettext('BS received');
gettext('The BS is valid only if  \nthe buffer is full');
gettext('If the buffer is empty,  \nthe BS is ignored');
gettext('Wait for the ENTER  \ncharacter');
gettext('The ENTER key has  \nbeen pressed');
gettext('Depending on the state of  \nthe buffer, the ENTER means  \na blank command or a data command');
gettext('When the stop input  \nis activated, an  \nabort tic is sent');
gettext('## INPUT-BIT-ECHO  \n\nWhen the machine is turned on, it waits for one  \nof the two symbols (default: '0' and '1') and  \ncoded them into oen bit, that is returned and  \nthe machine is turned off\n\nThe valid symbols are sent through the  \nstdout');
gettext('**Echo generator**  \nOnly the valid characters  \nare echoed');
gettext('## INPUT-BIT  \n\nWhen the machine is turned on, it waits for one  \nof the two symbols (default: '0' and '1') and  \ncoded them into oen bit, that is returned and  \nthe machine is turned off');
gettext('Input machine state:  \n0: OFF  \n1: ON');
gettext('If the machine is ON and the  \nsymbol is valid, the tic is  \nallowed to pass...');
gettext('## GETC-BIT  \n\nRead one bit of information. By default the  \ncharacteres '0' and '1' are converted into  \n1 bit');
gettext('Check if the character received is one of  \nthe two symbols expected');
gettext('The current caracter matches the  \nconstant specified (level output)');
gettext('Tic ouptput. The current character  \nmatches the constant');
gettext('The character matches one  \nof the two expected symbols ');
gettext('Output the current data  \ntic to the rcv pin');
gettext('## GETC-CHAR  \n\nDetects if a constant CHAR has arrived');
gettext('Check if the character received is the one  \nexpected (set by the parameter. Default: 0)');
gettext('Charactter detected:  \nOutput the current data  \ntic to the rcv pin');
gettext('hterm-bit');
gettext('## HTerm-bit\n\nHardware terminal with two commands: 0 and 1');
gettext('hterm-bitx2-stdout');
gettext('Hardware terminal with 2-bits binary commands');
gettext('Input 2-bits data in binary, with edition (BS and ENTER)');
gettext('2-bits bidirection shift register (left - right)');
gettext('Agregador de 2 cables en un bus de 2-bits');
gettext('DFF-rst. D Flip-Flop with load and reset. Implemented in verilog');
gettext('Stack pointer for 2 elements');
gettext('Separador de bus de 2-bits en dos cables');
gettext('## INPUTLN-BITx2-ECHO  \n');
gettext('If a bit is inserted in the buffer,  \nand it is not full yet...');
gettext('The receiver is activated if  \nan active BS is received');
gettext('2-position stack register  \nIt constrols the buffer state');
gettext('This tic is generated only if  \nthe buffer in NOT empty');
gettext('Insert the received  \nbit in the buffer');
gettext('Machine state');
gettext('**BUFFER**: Bidirectional  \nshift register  \nIt stores the bits received  \nWhen the BS is received, one  \nbit is removed from the buffer');
gettext('Reset the register  \nwhen the machine starts');
gettext('## 2-bits Shift register (left - right)\n\n');
gettext('Shift to the left (to MSB)');
gettext('Shift to the right (to lsb)');
gettext('Input when shifting right');
gettext('Input when shifting left');
gettext('Perform the shift  \n(etither right or left)');
gettext('##  SP-2  \nStack pointer for stacks of two elementos  \n');
gettext('The stack is empty');
gettext('The stack is full');
gettext('Push command');
gettext('Pop command');
gettext('According to the statck state,  the  \npush command is either ok or  \noverflow!');
gettext('According to the statck state,  the  \npop command is either ok or  \nunderflow!');
gettext('Load a new value  \nin the SP register');
gettext('**SP Register**');
gettext('reset the SP');
gettext('hterm-bitx2');
gettext('**AUX STDOUT BUS**');
gettext('Combine the main serial stdin bus  \nwith the second');
gettext('virtual-toggle-button');
gettext('Virtual serial toggle button');
gettext('## Virtual Toogle button\n\nIt toggle the output only when the  \n\"t\\n\" command is received on the serial  \nline  \nAny other commands are ignored.  \nAll the command should end with \\n');
gettext('**Serial input**');
gettext('Then /n characters resets  \nthe machine in the next cycle');
gettext('### Toggle comand detector  \n\nIt genetared the t_exec signal  \nonly when the patter \"t\\n\" is  \nreceived... but only after reset');
gettext('02-bits');
gettext('Print-ram-2x1-bit');
gettext('Serial debugger for print the address (1-bit) and data (1-bit) of a 2x1 RAM memory');
gettext('## Debugger: RAM 2x1\n\nComponent for debugging a 2x1 RAM  \nPrint the Address A (1-bit) and the data D (1 bit) with  \nthe format: \n\n```\n[A]: D\n```\n');
gettext('**Address**');
gettext('**Data**');
gettext('Bufferx1');
gettext('1-byte buffer');
gettext('Empty Buffer  \n(There is no byte  \nwaiting)');
gettext('Byte stored in the  \nbuffer, waiting to be  \ntransmitted when the  \ntransmitter is ready');
gettext('Buffer state:  \n0: empty  \n1: full');
gettext('Transmitter ready');
gettext('If the transmittter is ready  \nand there is a character  \nin the buffer: Transmit!');
gettext('Serial transmitter state');
gettext('Serial-rx');
gettext('stdin-bin-keyboardX4');
gettext('Stdin Binary keyboard, composed of 4 keys: 0, 1, backspace and Return');
gettext('FPGA internal pull-up configuration on the connected input port');
gettext('Detección de pulsación. Emite un tic cada vez que se aprieta el pulsador');
gettext('Codificador de 4 a 2, con prioridad. La salida zero se activa cuando ninguna entrada está activad');
gettext('Detector de flanco de bajada. Emite un tic cuando detecta un flanco descendente');
gettext('Circuito combinacional de 2 entradas y 8 salidas');
gettext('## STDIN-Bin-KeyboardX4\n\nKeyboard componente with 4-inputs: 0, 1, Backspace and ENTER\n\n');
gettext('**Return**');
gettext('**Backspace**');
gettext('**Key 1**');
gettext('**Key 0**');
gettext('**Pull-ups**');
gettext('Convert to positive  \nlogic');
gettext('**4-1 Codec**  \nOutput code:  \n0: Key 0  \n1: Key 1  \n2: Backspace  \n3: Return');
gettext('Conversion table:  \nGenerate the keycodes (8-bits)  for  \neach key');
gettext('Key pressed tic:  \nA tic is generated  \neverytime a key is  \npressed');
gettext('When no keys are pressed,  \nthe output is 1');
gettext('**Pulsador-tic**');
gettext('stdin-serial');
gettext('stdout-LEDs-8-rst');
gettext('8-bits Binary stdout device. The information is shown on the LEDs');
gettext('Decodificador de 3 a 8, con salida en bus');
gettext('Habilitación de bus de 8 bits');
gettext('XOR bit a bit entre dos buses de 8 bits');
gettext('Separador de bus de 8-bits en 1 buses de 6 bits y dos cables sueltos');
gettext('8-bits bus weight inverter');
gettext('3-bits up-down counter, with reset');
gettext('Sumador  de 4 bits (sin acarreo)');
gettext('Separador de bus de 4-bits en buses de 1 bits y 3 bits');
gettext('8x1 bits RAM memory with parallel output');
gettext('Demultiplexor de 1 bit, de 3 a 8 (salida de bus)');
gettext('Separador de bus de 8-bits en 8 cables');
gettext('Agregador de 8 cables de 1-bit a bus de 8-bits');
gettext('Multiplexor de 8 a 1, con entradas de bus');
gettext('Corazón de bombeo de tics a con periodo paramétrico de milisegundos, con reset');
gettext('Timer in ms, with stop input');
gettext('## STDOUT LEDs\n\nShow the STDout in the LEDs  \nThe less significant bit of the charactere  \nreceived is shown at the current cursor position');
gettext('Converti STDOUT into STDIN for reading   \ninterpreting the received characteres  \nusing stdin blocks');
gettext('Process the  \nENTER character');
gettext('Other charactere received');
gettext('Reset the device:  \n* Clear all the leds  \n* Cursor at home');
gettext('BS received:  \nmove the cursor back  \none character  \n(no deleting)');
gettext('Data received!  \nWrite the lsb in the current  \ncursor position and  \nmove to the next position');
gettext('**Cursor controller**');
gettext('The cursor is visible  \nIt is inside the leds zone');
gettext('Current cursor  \nposition');
gettext('cursor Position  \nupdated');
gettext('Move the cursor back  \none character');
gettext('Move the cursos forward  \none character');
gettext('Move the cursor  \nto home');
gettext('Generate the cursor:  it is  \none pixel that is blinking');
gettext('Insert the next signal into  \nthe stdout bus');
gettext('Only take one cycle  \nto process the character');
gettext('Data to show in the LEDs  \nEach address correspond to  \none LED');
gettext('Combine the data  \nwith the cursor');
gettext('Write the bit in the current  \ncursor position');
gettext('## Synchronous 8x1-bit RAM (Parallel)\n\n* Both the read and write operation are  \n  synchronous\n* The memory has parallel output');
gettext('Data input');
gettext('Write tic');
gettext('Paralell output');
gettext('standart reading');
gettext('**Each bit is store in its own flip-flop**');
gettext('Semiperiod');
gettext('**Arranque del**  \n**temporizador**');
gettext('**Salida de pulso**');
gettext('**Salida de tic**');
gettext('**Parametro del timer**  \nmilisegundos a esperar');
gettext('stdout-LEDs-8');
gettext('It only takes one cycle  \nto process the character');
gettext('stdout-serial-buffer');
gettext('Serial transmiter for the stdout bus (1 char buffer). Sysclk parameter');
gettext('Serial transmitter with a buffer for 1 byte');
gettext('stdout-serial-sysclk');
gettext('stdout-serial');
gettext('Serial transmiter for the stdout bus');
gettext('Transmisor serie');
gettext('Filters');
gettext('Getc');
gettext('InputLn');
gettext('Input_');
gettext('Print');
gettext('PrintLn');
gettext('Putc');
gettext('Regs');
gettext('Syntax');
gettext('Printable-nl-del');
gettext('Getc-bit');
gettext('Getc-char');
gettext('Getc-printable-char');
gettext('Receive a printable char');
gettext('## GETC-PRINTABLE-CHAR  \n\nDetects if the Char received is printable or not');
gettext('Printable char');
gettext('inputln-2xchars-echo');
gettext('inputln-bit-echo');
gettext('inputln-bitx2-echo');
gettext('inputln-char-echo');
gettext('Read one printable char from the input console, with edition (delete). Finish when enter is pressed');
gettext('When activated, it waits for a printable char to be received. This character is echoed (if valid)');
gettext('When active, waits for a printable char to be received');
gettext('## INPUTLN-CHAR-ECHO  \n');
gettext('Received char');
gettext('**BUFFER**  \nfor 1 char');
gettext('## INPUT-Printable-char-ECHO  \n\nWhen the machine is turned on, it waits for a\nprintable character, which is then returned \n\nThe printable characteres are sent through the  \nstdout');
gettext('Received character');
gettext('## INPUT-BIT  \n\nWhen the machine is turned on, it waits for a  \nprintable char to arrive, which is returned and  \nthe machine is turned off');
gettext('input-bit-echo');
gettext('input-bit');
gettext('input-printable-char-echo');
gettext('input-printable-char');
gettext('Print-bin');
gettext('Print-hex');
gettext('Print-int');
gettext('Print-strl-delay');
gettext('Print-uint');
gettext('asc');
gettext('print-str');
gettext('Print-base4-bin');
gettext('Print a base4 number in Binary');
gettext('02-Reg: 2 bits Register. Verilog implementation');
gettext('Base 4 number to print');
gettext('Print-bin-03-bits');
gettext('Print a 3-bits number in Binary');
gettext('03-SL-ld: 3 bits shift left register with load. Verilog implementation');
gettext('## Print-bin-3-bits: Transmit one 3-bits number in Binary\n\nWhen activated, the 3-bits number is sent as three binary  \ncharacters (0/1)');
gettext('Print-bin-04-bits');
gettext('Print a 4-bits number in Binary');
gettext('04-SL-ld: 4 bits shift left register with load. Verilog implementation');
gettext('## Print-bin-4-bits: Transmit one 4-bits number in Binary\n\nWhen activated, the 4-bits number is sent as three binary  \ncharacters (0/1)');
gettext('Print-bin-08-bits');
gettext('Print a 8-bits number in Binary');
gettext('## Print-bin-8-bits: Transmit one 8-bits number in Binary\n\nWhen activated, the 8-bits number is sent as three binary  \ncharacters (0/1)');
gettext('Print-bin-16-bits');
gettext('Print-hex-12bits');
gettext('Print a 12-bit number in hexadecimal numbers');
gettext('Split the 12-bit bus into a 3 buses of 4-bits ');
gettext('12-Reg: 12 bits Register. Verilog implementation');
gettext('## Print-hex-12: Print a 12-bit number in hexadecimal');
gettext('Print-hex-16bits');
gettext('Print a 16-bit number in hexadecimal numbers');
gettext('Separador de bus de 16-bits en buses de 8 bits');
gettext('Mach-count-2-bits: 2-bits count machine');
gettext('OR-BUS2: OR gate with 2-bits bus input');
gettext('Bus2-Split-all: Split the 2-bits bus into two wires');
gettext('Counter-x02: 2-bits counter');
gettext('Inc1-2bit: Increment a 2-bits number by one');
gettext('AdderK-2bit: Adder of 2-bit operand and 2-bit constant');
gettext('Generic: 2-bits generic constant (0,1,2,3)');
gettext('Adder-2bits: Adder of two operands of 2 bits');
gettext('Adder-1bit: Adder of two operands of 1 bit');
gettext('AdderC-1bit: Adder of two operands of 1 bit plus the carry in');
gettext('XOR gate: two bits input xor gate');
gettext('Bus2-Join-all: Joint two wires into a 2-bits Bus');
gettext('16-Reg: 16 bits Register. Verilog implementation');
gettext('## Print-hex-16: Print a 16-bit number in hexadecimal');
gettext('counter');
gettext('n>0');
gettext('The machine is active: either in the first  \nstate cycle (n=0) or the next cycles (n>0)');
gettext('Then count machine has three states:  \n\n* Idle: The machine is off, waiting to receive the start signal  \n* n = 0: Initial state cycle. It goes from receiveing the start signal until  \n  the first next signal arrives\n* n > 0: state cycles. From the first next signal to the fourth');
gettext('¿State different than 0?');
gettext('Print-hex-32bits');
gettext('Print a 32-bit number in hexadecimal numbers');
gettext('Separador de bus de 32-bits en 4 buses de 8 bits');
gettext('4-bit 8-1 mux (Flip)');
gettext('Mach-count-3-bits: 3-bits count machine');
gettext('OR-BUS3: OR gate with 3-bits bus input');
gettext('OR3: Three bits input OR gate');
gettext('Bus3-Split-all: Split the 3-bits bus into three wires');
gettext('Counter-x03: 3-bits counter');
gettext('Inc1-3bit: Increment a 3-bits number by one');
gettext('AdderK-3bit: Adder of 3-bit operand and 3-bit constant');
gettext('Generic: 3-bits generic constant (0-7)');
gettext('Adder-3bits: Adder of two operands of 3 bits');
gettext('Bus3-Join-all: Joint three wires into a 3-bits Bus');
gettext('03-Reg: 3 bits Register. Verilog implementation');
gettext('32-Reg: 32 bits Register. Verilog implementation');
gettext('Hex digit to print:  \n');
gettext('## Print-hex-32: Print a 32-bit number in hexadecimal');
gettext('3-bits counter');
gettext('Print-hex-8bits');
gettext('Print-int12');
gettext('Print a 12-bits signed integer (-2048, 2047)');
gettext('Calculate the 2's complemente of a 12-bits number');
gettext('12-bits bus not gate');
gettext('Sumador de un operando de 12 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Extractor de 1 bit de un bus de 12 bits');
gettext('Print an 12-bits unsigned integer (0 - 255)');
gettext('Máuina de conversion Binario - BCD de 12 bits');
gettext('12-SL-ld: 12 bits shift left register with load. Verilog implementation');
gettext('2-to-1 Multplexer (12-bit channels). Verilog implementation');
gettext('## Print-int12: Print a 12-bits signed integer (-2048, 2047)\n\n');
gettext('Machine state: ON/OFF');
gettext('Calculate the  \nnumber two's complement');
gettext('Capture the number only  \nin the begining');
gettext('Sign bit');
gettext('Depending on the sign bit,  \nselect the number or its  \ntwo complement');
gettext('If the nunmber is negative,  \nprint the \"-\" char first');
gettext('4 stages machine:  \n* stage=0: print the MS digit\n* stage=1: print the next digit\n* stage=2: Print the next digit\n* stage=3: print the LS digit');
gettext('Dígito 3');
gettext('Print-int16');
gettext('Print a 16-bits signed integer (-32768, 32767)');
gettext('Calculate the 2's complemente of a 16-bits number');
gettext('16-bits bus not gate');
gettext('Sumador de un operando de 16 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Extractor de 1 bit de un bus de 16 bits');
gettext('Print an 16-bits unsigned integer (0 -65535)');
gettext('Multiplexor de 8 a 1 de 4 bits');
gettext('Comparador de igualdad, de un operando de 3 bits');
gettext('Máuina de conversion Binario - BCD de 16 bits');
gettext('2-to-1 Multplexer (16-bit channels). Verilog implementation');
gettext('## Print-int16: Print a 16-bits signed integer (-32768, 32767)\n\n');
gettext('## Print-uint16: Print a 16-bits unsigned integer (0 - 65535)\n\n');
gettext('5 stages machine:  \n* stage=0: print the MS digit\n* stage=1: print the next digit\n* stage=2: Print the next digit\n* stage=3: Print the next digit\n* stage=4: print the LS digit');
gettext('Dígito 4');
gettext('Print-int4');
gettext('Print a 4-bits signed integer (-8, 7)');
gettext('Calculate the 2's complemente of a 4-bits number');
gettext('Puerta NOT para bus de 4 bits');
gettext('Extractor de 1 bit de un bus de 4 bits');
gettext('Print an 4-bits unsigned integer (0 - 15)');
gettext('Conversor de binario a BCD, para números de 4 bits');
gettext('4bits constant value: 0');
gettext('Generic: 4-bits generic constant (0-15)');
gettext('## Print-int4: Print a 4-bits signed integer (-8, 7)\n\n');
gettext('## Print-uint4: Print a 4-bits unsigned integer (0 - 15)\n\n');
gettext('2 stages machine:  \n* dig=0: print the MS digit\n* dig=1: Print the LS digit');
gettext('In the first stage the  \nnumber n is registered');
gettext('First stage');
gettext('Digit to print');
gettext('The MS digit is 0');
gettext('The exec tic is delayed 1 cycle because in  \nthe first stage the number should be registered');
gettext('Stage 1: is always ok: the  \nLSB should always be printed');
gettext('Stage 0: The MS dig is printed always  \nif it is different from 0  \nIf it is 0, it is printed depending  \non the SIZE2 parameter: \n* SIZE2 = 0: Not printed  \n* SIZE2 = 1: Printed');
gettext('The MS digit is 0  \nand we do not want it  \nto be printed');
gettext('NOT Fixed size');
gettext('MS Digit is 0');
gettext('Print-int8');
gettext('Print a 4-bits signed integer (-128, 127)');
gettext('Calculate the 2's complemente of a 8-bits number');
gettext('Puerta NOT para bus de 8 bits');
gettext('Sumador de un operando de 8 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Extractor de 1 bit de un bus de 8 bits');
gettext('## Print-int8: Print a 8-bits signed integer (-128, 127)\n\n');
gettext('Print-delay-str-0064');
gettext('Print a constant string of 63 or less characters, with a delay between characters');
gettext('Unit-ms-32bits: ms to cycles converter');
gettext('Sys-Delay-xN-32bits: The input tic is delayed N cycles');
gettext('Counter-M-x32: 32-bits M module counter with reset');
gettext('Inc1-32bit: Increment a 32-bits number by one');
gettext('AdderK-32bit: Adder of 32-bit operand and 32-bit constant');
gettext('Generic: 32-bits generic constant');
gettext('Adder-32bits: Adder of two operands of 32 bits');
gettext('Adder-8bits: Adder of two operands of 8 bits');
gettext('Bus8-Split-half: Split the 8-bits bus into two buses of the same size');
gettext('Adder-4bits: Adder of two operands of 4 bits');
gettext('Bus4-Split-all: Split the 4-bits bus into its wires');
gettext('Bus4-Join-all: Join all the wires into a 4-bits Bus');
gettext('Bus8-Join-half: Join the two same halves into an 8-bits Bus');
gettext('AdderC-4bits: Adder of two operands of 4 bits and Carry in');
gettext('AdderC-8bits: Adder of two operands of 8 bits and Carry in');
gettext('Bus16-Join-half: Join the two same halves into an 16-bits Bus');
gettext('Bus24-Join-8-16: Join the two buses into an 24-bits Bus');
gettext('Bus32-Split-8-24: Split the 28-bits bus into two buses of 8 and 24 wires');
gettext('Bus24-Split-16-8: Split the 24-bits bus into two buses of 16 and 8 wires');
gettext('Bus16-Split-half: Split the 16-bits bus into two buses of the same size');
gettext('Bus32-Join-8-24: Join the two buses into an 32-bits Bus');
gettext('Geu-32-Bits_v: 32-bit Unsigned Greather than or equal comparator. Verilog implementation');
gettext('32-Reg-rst: 32 bits Register with reset. Verilog implementation');
gettext('## PRINT-delay: Print a string with a delay between their characteres\n\n');
gettext('Input parameter: Milieconds  ');
gettext('Input parameter:  \nSystem Frequency');
gettext('Cycles to delay');
gettext('Delay finished!');
gettext('RS Flip-Flop');
gettext('Circuit state:  \n* ON: working (1)\n* OFF: Not working (0)');
gettext('The counter has reached  \nthe number of cycles  \nto delay');
gettext('Maximum count  \nreached');
gettext('32-bits register');
gettext('If the max count is reached  \nand the cnt tic is received,  \nthe register is reset to 0');
gettext('External reset');
gettext('Print-uint12');
gettext('Print-uint16');
gettext('Print-uint4');
gettext('Print-uint8');
gettext('Print-asc-0002');
gettext('Print a constant string defined by 2 ascii bytes');
gettext('2 Bytes Synchronous memory');
gettext('Memory with the string  \nto be transmited (in ASCII)');
gettext('Print-asc-0004');
gettext('Print a constant string defined by 4 ascii bytes');
gettext('Print-asc-0008');
gettext('Print a constant string defined by 8 ascii bytes');
gettext('8 Bytes Synchronous memory');
gettext('Print-asc-0016');
gettext('Print a constant string defined by 16 ascii bytes');
gettext('16 Bytes Synchronous memory');
gettext('Print-asc-0032');
gettext('Print a constant string defined by 32 ascii bytes');
gettext('32 Bytes Synchronous memory');
gettext('Print-asc-0064');
gettext('Print a constant string defined by 64 ascii bytes');
gettext('64 Bytes Synchronous memory');
gettext('Print-asc-0128');
gettext('Print a constant string defined by 128 ascii bytes');
gettext('128 Bytes Synchronous memory');
gettext('Print-asc-0256');
gettext('Print a constant string defined by 256 ascii bytes');
gettext('Máquina de contar, de 8 bits, con entrada de stop');
gettext('Comparador de dos operandos de 8 bits');
gettext('Valor genérico constante (menos 1), de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('08-Reg-rst: 8 bits Register with reset. Verilog implementation');
gettext('256 Bytes Synchronous memory');
gettext('Print-str-0002');
gettext('Print a constant 1-char string');
gettext('2-bytes memory, initilized with a string');
gettext('Print-str-0004');
gettext('Print-str-0008');
gettext('Print-str-0016');
gettext('Print-str-0032');
gettext('Print-str-0064');
gettext('Print-str-0128');
gettext('Print-str-0256');
gettext('Print a constant string of 256 or less characters');
gettext('256-bytes memory, initilized with a string');
gettext('PrintLn-BitVar');
gettext('Print a Bit variable + LF');
gettext('## PRINTLN-bit-var\n\nPrint a Bit Variable. The output format is:  \n< Varname > < Bit > < LN >  \nWehre < Varname >  is a 1-char variable identifier\n\nExample: \"a1\\n\"');
gettext('Print the Variable  \nidentfifies');
gettext('Print the variable  \nbit value + \\n');
gettext('Before print, both variable name  \nand variable value are store into  \na register');
gettext('Store the variable  \nname');
gettext('Store the bit  \nvalue');
gettext('This print machine  \ngets busy as soon as  \nthe print gets high');
gettext('PrintLn-OK');
gettext('PrintLn-base-4');
gettext('PrintLn-bit');
gettext('PrintLn-char');
gettext('putc-base4');
gettext('putc-bit');
gettext('putc-char-const');
gettext('putc-char');
gettext('putc-hex');
gettext('08-bits-shift-right-load-rst');
gettext('8bits shift right register with reset and paralell load');
gettext('Serial out');
gettext('**Reset**. The register is  \ninitialized with the INI  \nparameter');
gettext('Serial input');
gettext('Paralell data');
gettext('**load** the paralell  \ndata into the register');
gettext('**Shift** right 1-bit');
gettext('Syntax-ELSE');
gettext('Syntax-EOL');
gettext('Syntax End Of Line. Last block when detecting a command');
gettext('Last block:  \nIt is blocked with any  \ncharactere received');
gettext('The received char was  \nan END of LINE: OK!');
gettext('## Syntax EOL\n\nThis block should be the last one. It checks if the last correct  \ncharactere received is an end-of-line\n\nAs it is the last block, it always get blocked when a characterer  \narrives. If it is an EOL, it is send through the ok_tic\n');
gettext('Syntax-bit');
gettext('bit syntax block');
gettext('## Syntax Bit  \n\nSyntax block for receiving a bit ('0'/'1')\n\nWhen the character recived is a bit,  \nit gets activated, and the blocks becomes into a wire (transparent mode)  \nuntil it is reset\n\nIf the first received character is not a bit,  \nthe block blocks. it disconnects itself from the input until it is reset');
gettext('State of the received character  \n0: No bit symbol received  \n1: Bit received ');
gettext('Bit received:  \nChange to   \nactive mode');
gettext('**Block state**  \n0: Not blocked  \n1: Blocked');
gettext('Capture the bit  \nreceived');
gettext('Syntax-char');
gettext('Debug');
gettext('General');
gettext('Getc');
gettext('InputLn');
gettext('Input_');
gettext('Input_echo');
gettext('Multi-board');
gettext('Print');
gettext('PrintLn');
gettext('Putc');
gettext('Syntax');
gettext('stdin-stdout');
gettext('2x1-bits-memory-test');
gettext('Detect changed on the input signal ');
gettext('Detector de flancos de subida y bajada. Emite tic por las salidas correspondientes al detecta los flancos');
gettext('2x1 bits RAM memory');
gettext('Detect different clicks on the button: normal click, doble click or long click');
gettext('Pulsador con tic de cambio, pulsación y liberación de tecla');
gettext('Sincronizar las entradas de datos con el reloj del sistema');
gettext('Remove the rebound on a mechanical switch');
gettext('Test if a tic is received within time');
gettext('Timer in ms, with start and stop');
gettext('Corazón de bombeo de tics, cuyo periodo está especificado en micro-segundos. Solo se hace el bombeo cuando está habilitado');
gettext('Contador módulo M, ascendente, de 12 bits, con reset ');
gettext('# 2x1 bits Memory\n\nExample of accesing to a 2x1 bits memory  \n* Click on button 1: Change the current addres (0/1)  \n* Click on button 2: Change the current data to write (0/1)  \n* Long click on button 2: Writing the current data into the current address\n\n');
gettext('**Current address**  \nIt is changed on everyt click  \nof button 1');
gettext('Show current address  \non LED7');
gettext('Long click on button 2  \nfor writing data on  \nthe memory');
gettext('Detect a change on the  \naddress');
gettext('**Print memory status**  \nThe current address and data  \nare printed on the console');
gettext('Print when there is a change  \nin the address');
gettext('or whenever there  \nis a write');
gettext('or after the reset');
gettext('**Current data**  \nIt is changed on every  \ntick of button 2');
gettext('Show current data  \non LED0');
gettext('## Memory');
gettext('Data from  \nthe memory');
gettext('## Change detector  \n\nIt emits the followings tics:\n\n* When there is a rising edge on the input signal\n* When there is a falling edge\n* When there is either a rising or falling edge');
gettext('## Detector doble: flancos de subida y bajada\n\nSe detectan tanto los flancos de subida como de bajada y se emite los  \ntics por sus salidas correspondientes');
gettext('Señal de  \nentrada');
gettext('Reloj del  \nsistema');
gettext('## Synchronous 2x1-bit RAM\n\n* Both the read and write operation are  \n  synchronous');
gettext('Address (0/1)');
gettext('Depending on the address,  \nsend the tic write to the  \ncorresponding flip-flop');
gettext('Demux-2-1');
gettext('Flip-Flop 0');
gettext('Flip-Flop 1');
gettext('Flip-flops are loaded with  \nthe data input when the  \nwrite tic is received');
gettext('Read operation:  \nOutput the selected  \nflip-flop');
gettext('The read data will be available  \non the next cycle');
gettext('## Button-click-3  \n\nDetect three different types of clicks in the Button:\n\n* Normal click  \n* Doble click  \n* Long click');
gettext('When the button is pressed  \nthe timer 1 is started');
gettext('If the button is pressed again  \nwithin the time, it is  \na doble click');
gettext('Timeout: It was  \nnot a doble click');
gettext('Check the current  \nbutton state: pressed  \nor not pressed');
gettext('Button state');
gettext('Button state:  \n1: Pressed  \n2: Not pressed');
gettext('Button is released:  \nwe have a click  \nIt is NOT a long click');
gettext('Button is still  \npressed: we do not know yet  \nif it is a click or long click');
gettext('Timeout for detecting a \ndoble click  \nAfter this time is not considered a  \ndoble click but two clicks in a row');
gettext('Wait for the release  \ntic');
gettext('Release tic has arrived  \nwithin time: it was a  \nnormal click  ');
gettext('In both cases it is  \nconsider a normal click');
gettext('The button has not been  \nreleased after the specified  \ntime: it is a long click');
gettext('**Outputs**');
gettext('## Timer-ms\n\nWhen the machine is active, it detects if  \nan input tic arrive within the specified time  \nIf so, another tic is sent to done. If no tic is  \nreceived within time (timeout), a tic is sent  \nto tout');
gettext('Start the machine');
gettext('Tic to detect within time');
gettext('Main timer');
gettext('Start the timer');
gettext('If a tic is received when  \nthe timer is still on,  \nlet it pass...');
gettext('The tic is delayed one unit  \nto prevent reache the timer  \nin the same cycle than start  \n(it can happens if the same tic is  \nconnect both to start and tic inputs)  ');
gettext('Stop the timer:  the tic  \nhas arrived in time');
gettext('The tic arrived in time  \nTic detected!');
gettext('No tic detected  \nwithin time');
gettext('tic: No input tic detected');
gettext('tic: input tic detected!');
gettext('Biestable de estado  \nde la máquina');
gettext('Mientras la máquina  \nesté apagada el  \ncontador está a 0');
gettext('Contador de tiempo  \nen unidades de  \nmilisegundos');
gettext('El tiempo ha expirado:  \napagar la máquina');
gettext('Unidades de tiempo:  \n1000 microsec = 1ms');
gettext('Al arrancar la máquina,  \neste corazón emite un  \ntic cada 1 ms');
gettext('**Parámetro**:  \nms de espera');
gettext('Sacar el tic de apagado de  \nla máquina por abort o done  \nsegún cómo haya sido');
gettext('Si es por stop: El timer ha abortado  \nSi no, es una terminación normal (timeout)');
gettext('**Parámetro**: Módulo del contador');
gettext('Base4-counter');
gettext('Simplified-Heart-tic-hz-sys-32bits: Nominal periodic signal in hz');
gettext('Unit-hz-32bits: hz to cycles converter');
gettext('Heart-sys-zero-32bits: Generate a periodic signal of period T cycles. It starts at cycle 0. It never stops');
gettext('Generate tics');
gettext('Transmit the current number');
gettext('Count from 0 to 3');
gettext('## Base 4 counter\n\nIt prints the count from 0 to 3 on  \nthe console');
gettext('Delay');
gettext('Start a new period');
gettext('Start at cycle 0!');
gettext('Repeat!');
gettext('Current period ended  \nStart a new one');
gettext('Periodo (in system clock cycles)');
gettext('Current cycle in the period  \n(0-T-1)');
gettext('Hello-world');
gettext('## Hello World\n\nIt prints the string \"Hello World\"  \nafter the reset');
gettext('Hterm-toggle-LED');
gettext('# Toggle-led\n\nThe LED7 is toggle with the cmd t  \nAny other command will show the  \n\"unkwnon command\" message\n\n');
gettext('### Example\n\n```\nHterm 0.5\n? for help\n>?\nHterm 0.5-Toggle\nAvailable commands:\n? : This help\nt : Toogle the state\n\n>t\n1\nOK!\n>t\n0\nOK!\n>hd\nUnknown command\n>\n```');
gettext('Mini-local-input-console-test-01');
gettext('## Keyboard STDIN test: HTerm-LEDs\n\nThe 2-bits binary input is shown in two LEDs  \nThe serial consola and the local keyboard STDIN  \nare used');
gettext('Mini-local-input-console-test-02');
gettext('Valor genérico constante, de 10 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('## 2-bits binary to decimal conversor\n\nThe 2-bits binary numbers are converted into  \nit decimal representation (base 4: 0,1,2 and 3)  \nThe numbers are introduced either by the serial console  \nor the keyboard  \n\nThe terminal edition is shown on the console and in  \nthe external leds');
gettext('Print the 2-bits number  \nas a decimal digit');
gettext('Show the terminal in  \nthe LEDs console');
gettext('Keyboard input');
gettext('Show the number in the  \nLEDs (in binary)  ');
gettext('Number entered');
gettext('The LEDs terminal es  \nreset on every prompt  \nrequest');
gettext('Print the entered number on the  \nconsole');
gettext('Previous command finished  \nRequest for the prompt');
gettext('When the inputln is active,  \nthe output is also sent  \nto the leds');
gettext('hterm-bit-stdout-test-1-2x1-memory');
gettext('Comparador de dos operandos de 1 bit');
gettext('2x1 bits RAM memory with parallel output');
gettext('Blank cmd:  \nDump the memory');
gettext('## Memory dump');
gettext('Select the address for accesing  \nthe memory:  \n0: Addres for writing  \n1: Adress for reading');
gettext('Address for reading');
gettext('After reading,  \nprint the data');
gettext('Data to read');
gettext('Write comand');
gettext('Writing finished');
gettext('Write pointer');
gettext('The reading address  \nis equal to the current  \nwrite pointer');
gettext('Conditional print:  \nIf addr == wp:  \n  print(\"*\")');
gettext('## Print the address and its content\n\nOne line is printed, with the address on the left  \nand its content on the right. An * is printed if this  \nis the current address to write\n\n```[0]: 0```');
gettext('Before dumping the memory, the  \nwrite pointer is incremented');
gettext('## HTerm  \n\n0,1 and blank commands');
gettext('## Synchronous 2x1-bit RAM (Parallel)\n\n* Both the read and write operation are  \n  synchronous\n* The memory has parallel output');
gettext('hterm-bit-stdout-test-2-one-element-stack');
gettext('Stack pointer for 1 element');
gettext('Blank cmd:  \npop');
gettext('## 1 element stack\n\nSimple stack composed of 1 bit. The interface is the HTerm  \nThe digit introduce are store in the stack (only the first)  \nIf another element is entered when the stack is full, the  \noverflow message is gotten.   \n\nThe blank command is used for poping the element. A pop command  \nentered when the stack is empty will produce an undeflow message');
gettext('Stack pointer for   \n1 element stack');
gettext('Turn on the LED when the  \nstack is full');
gettext('Turn on the LED when the  \nstack is empty');
gettext('Bit in the stack');
gettext('Command finished  \nPrint the prompt');
gettext('Bit to store  \nin the stack');
gettext('**Stack state:**  \n0: empty  \n1: Full');
gettext('##  SP-1  \nStack pointer for stacks of only 1 element!  \n');
gettext('The push cmd is valid is the  \nstack is empty');
gettext('The pop cmd is only valid  \nif the stack is full');
gettext('According to the stack state,  the  \npop command is either ok or  \nunderflow!');
gettext('hterm-bit-stdout-test-3-two-elements-stack');
gettext('Button-tic: Configurable button that emits a tic when it is pressed');
gettext('Configurable button (pull-up on/off. Not on/off)');
gettext('FPGA internal pull-up configuration on the input port');
gettext('Select positive or negative logic for the input (0=positive, 1=negative)');
gettext('Edges detector. It generates a 1-period pulse (tic) when either a rising edge or a falling edge is detected on the input. Block implementation');
gettext('16-bits Syscounter with reset');
gettext('Inc1-16bit: Increment a 16-bits number by one');
gettext('AdderK-16bit: Adder of 16-bit operand and 16-bit constant');
gettext('Generic: 16-bits generic constant');
gettext('Adder-16bits: Adder of two operands of 16 bits');
gettext('16-Sys-reg-rst: 16 bits system register with reset. Verilog implementation');
gettext('Sync-x01: 1-bit input with the system clock domain (Verilog implementation)');
gettext('## 2 elements stack\n\nStack composed of two elementos of 1 bit. The interface is the HTerm  \nThe digit introduce are store in the stack\nIf another element is entered when the stack is full, the  \noverflow message is gotten.   \n\nThe blank command is used for poping elements. A pop command  \nentered when the stack is empty will produce an undeflow message');
gettext('Stack pointer for   \na 2 elements stack');
gettext('Button state signal');
gettext('Tic: button pressed');
gettext('Rising edge detector');
gettext('Pull up on/off');
gettext('Not on/off');
gettext('Internal pull-up  \n* 0: OFF\n* 1: ON');
gettext('Synchronization stage');
gettext('Normalization stage\n\n* 0: Wire\n* 1: signal inverted');
gettext('Debouncing stage');
gettext('### Pull-up parameter:\n\n0: No pull-up  \n1: Pull-up activated');
gettext('Only an FPGA pin can  \nbe connected here!!!');
gettext('The pull-up is connected  \nby default');
gettext('When k=0, it works like a wire  \n(The output is equal to the input)  \nWhen k=1, it act as a not gate\n(The output is the inverse of the input)');
gettext('### Truth table for XOR\n\n| k | input | output | function |\n|---|-------|--------|----------|\n| 0 | 0     |  0     | wire     |\n| 0 | 1     |  1     | wire     |\n| 1 | 0     |  1     | Not      |\n| 1 | 1     |  0     | Not      |');
gettext('Edge detector');
gettext('Whenever there is a change in  \nthe input, the counter is started');
gettext('If the counter reaches it maximum  \nvalue, the input is considered stable  \nand it is captured');
gettext('### Time calculation\n\nFor CLK=12MHZ, a 16-bit counter reaches its  \nmaximum every 2 ** 16 * 1/F = 5.5ms aprox  \nIF more time is needed for debouncing,  \nuse a counter with more bits (17, 18...)');
gettext('## Debouncer  \n\nA value is considered stable when  \nthere is no changes during 5.5ms  \naprox. When a value is stable it is  \ncaptured on the output flip-flop');
gettext('Stable output');
gettext('Counter');
gettext('## Edges detector\n\nIt generates a 1-period pulse (tic) when an edge (Rising or falling) is detected on the  \ninput signal');
gettext('The output is 1 if the current value is 1 and the  \nprevious 0, or if the current value is 0 and the  \nprevious 1\n');
gettext('In any other case the output is 0');
gettext('hterm-bit-test-1');
gettext('# HTerm-bit\n\nMini-terminal with two commands: 0 and 1  \nThis commands are used for turning a LED on/off');
gettext('Store the received  \ncommand');
gettext('hterm-bitx2-test-1-LEDs');
gettext('## HTerm  \n\n2-bits data and blank commands');
gettext('## hterm-bitx2 Test: LEDs\n\nThe 2-bits binary input is shown in two LEDs  \nThe blank comands reads the value stored');
gettext('Print stored value');
gettext('Store the number entered');
gettext('ok-button');
gettext('## PrintLn OK Test\n\nIt prints the string \"OK\" when the button  \nis pressed');
gettext('virtual-toggle-button-test');
gettext('## Virtual Toggle Button Test 1: LED  \n\nChange the LED using the Virtual serial toggle button ');
gettext('2x1-bits-memory-test');
gettext('Base4-counter');
gettext('Hello-world');
gettext('Hterm-toggle-LED');
gettext('Mini-local-input-console-test-01');
gettext('Mini-local-input-console-test-02');
gettext('hterm-bit-stdout-test-1-2x1-memory');
gettext('hterm-bit-stdout-test-2-one-element-stack');
gettext('hterm-bit-stdout-test-3-two-elements-stack');
gettext('hterm-bit-test-1');
gettext('hterm-bitx2-test-1-LEDs');
gettext('ok-button');
gettext('virtual-toggle-button-test');
gettext('01-print-matrix');
gettext('**Reset, HOME**  \n**CLS, GREEN**');
gettext('* Reset: \"\\033[0m\"  \n* Home:  \"\\033[H\"\n* CLS: \"\\033[2J\"\n* Green color (fg): \"\\033[32;1m\"\n\n');
gettext('https://www.youtube.com/watch?v=kIXNpePYzZU\n\nCall trans opt: received. 2-19-98 13:24:18 REC:Log>  \nTrace program: running\n');
gettext('## Example 1: Matrix (Opening scene)  \n\nTwo messages are printed on the console in green color  \nThe printing emulates a slow terminal  \n\n');
gettext('**Message 1**');
gettext('**Message 2**');
gettext('02-Button-state-ANSI');
gettext('## Example 2: Big button state  \n\nThe state of the pushbutton is shown in big ANSI digits  \n');
gettext('The tic activates on print  \nor another depending on the state  \nof the button');
gettext('03-cowsay-bin');
gettext('## Example 3: Cowsay  \n\nCow say the state of the button :-)\n');
gettext('The button is pressed');
gettext('The button is released');
gettext('04-NOT-truth-table');
gettext('## Example 4: Not gate truth table  \n\nThe NOT truth table is generated automatically\n');
gettext('**Start here**');
gettext('Count machine');
gettext('## Circuit to simulate');
gettext('**New line**');
gettext('05-ram-2x1-bit-test-term');
gettext('## Write-Mode STDOOUT');
gettext('Writting addr');
gettext('**Input data**');
gettext('## Dump-Mode STDOOUT');
gettext('Dump data');
gettext('## Write Mode Machine');
gettext('## Dump Mode Machine');
gettext('Select which address to use  \ndepending on the mode');
gettext('# Terminal for a 2x1 bits Memory\n\nFirst you are asked for the memory values (writing mode)  \nThen the memory values are printed on the console  \nThe process is repeated indefinitely\n\n');
gettext('06-Hcalc-acumulator');
gettext('2-ops 2-bits adder (no carry)');
gettext('Wait for the user to enter  \nthe '1' or '0' commands');
gettext('Print the welcome message');
gettext('Total msg');
gettext('# HCALC-0.1-acumulator\n\n1-bit calculator. It calculates the adition of bits  \nThe result is shown in 1 bit  ');
gettext('Operand to add');
gettext('Do the operation!');
gettext('2-bits acumulator');
gettext('Calculate op + acc');
gettext('acc = acc + op');
gettext('Print the least significant  \nbit of the acumulator');
gettext('Print the Total value');
gettext('07-Hcalc-terminal');
gettext('# HCALC-prompt\n\n1-bit calculator.  The user inputs two operands');
gettext('Primer operando');
gettext('Segundo operando');
gettext('Máquina de dos estados:  \n0: Captura del primer operando  \n1: Captura del segundo operando');
gettext('Suma conbinacional');
gettext('Resultado de la  \nsuma (en 1 bit)');
gettext('Primer cálculo,  \ntras el reset');
gettext('Resto de cálculos');
gettext('08-Hcalc-expresion');
gettext('Puerta XOR');
gettext('# HCALC-expresion\n\n1-bit calculator.  The user inputs two operands');
gettext('Según el operando que toque,  \nse imprime un mensaje u otro');
gettext('La suma de numeros  \nde 1 bit se implementa  \ncon una puerta XOR');
gettext('Según el operando que toque,  \nse almacena en un biestable  \nu otro');
gettext('09-Hcalc-stack');
gettext('2-bits stack pointer');
gettext('# HCALC: Stack example 1\n\nAdding two 1-bit numbers using the stack  \nIt is divided in two stages:  \n\n1) Fist, the elements are introduce by  \nthe user and stored on the stack\n\n2) Secod, the operands are read from the  \nstack, added and printed the result on  \nthe console');
gettext('Pushing 2 operands  \ninto the stack');
gettext('Poping 2 operands  \nfrom the stack');
gettext('PUsh the next  \noperand');
gettext('Push the current  \noperand');
gettext('Ask the user to  \nenter the current  \noperand');
gettext('### Stack Pointer');
gettext('Push data  \non the stack');
gettext('### Memory');
gettext('One cycle after pushing the  \noperando, push the next one');
gettext('One cycle after reading,  \npop the next operand');
gettext('Operand to pop:  \n0: First  \n1: Second');
gettext('Send the read tic to the   \ncorresponding biestable  \nfor storing the operand');
gettext('First operand');
gettext('Second operand');
gettext('Perform the  \naddition of the  \ntwo operands');
gettext('**Printing the Result**');
gettext('2-bit register  \nCurrent posicion');
gettext('Value 3 is used when  \nthe stack is empty');
gettext('## 2-bits Stack Pointer\n\nIt only have 3 position for storing information:  \n0,1 and 2. The 3 is used for indicaning empty stack\n\nIt is it initial value (3 = -1)\n\nWhen the up tic is received, the sp is incremented (but it will never  \nbe higher than its maximum value of 2) and the push tic is emitted  \n(on the next cycle) for being synchronyzed with the sp value\n\n');
gettext('When the down tic is received, the pop tic is emitted and then the sp is decremented  \n(but it cannot be lower than -1). Therefore the pop tic comes before the sp is  \ndecrement. The external circuit has one cycle to read the current value at the top. In  \nthe next cycle the sp is decremented. This approach makes it very easy to implement the  \npop operation on a memory\n\nThe changed tic is emitted whenever the sp has changed  \n(either increased or decreased)');
gettext('Incremented value of  \nthe sp');
gettext('Decremented value  \nof the sp');
gettext('Current sp value');
gettext('Select the value  \nfor updating the  \ncurrent sp');
gettext('valid Change in the  \ninput tics');
gettext('There was a change  \nin the sp register');
gettext('2-1 coder');
gettext('The sp is NOT at TOP  \nand up-tic is received');
gettext('It is ok to  \nincrement the sp');
gettext('The sp is NOT EMPTY  \nand down-tic is received');
gettext('It is ok to  \ndecrement the sp');
gettext('10-Hcalc-two-elements-stack');
gettext('## HCalc stack  \n\nTwo operands stack calculator. The elements are 1-bit  \nFirst you should introduce two bits and the issue the  \nblank commad. The sum is printer or an underflow error\n\n');
gettext('Operation state:  \n0:  OK\n1: Underflow!  \nEverytime a new command is started  \nthe error is cleared');
gettext('**Máquina para leer**  \n**los dos operandos**');
gettext('Current operand:  \n0: First operand  \n1: Second operand  ');
gettext('According to the error, the done tic  \nis sent to one block or another');
gettext('pop the current operand');
gettext('Store the operand in different  \nflip-flips');
gettext('Operand 0');
gettext('Operand 1');
gettext('Add the two  \n1-bit operators');
gettext('Read next operand');
gettext('Result');
gettext('11-Hcalc-2bits-acumulator');
gettext('Sumador  de 2 bits (sin acarreo)');
gettext('Add command');
gettext('Show the result on  \nthe LEDs');
gettext('**Print the result**');
gettext('The operand introduce by the  \nuser is only 1-bit. Convert  \ninto a 2-bits number');
gettext('The result is printed either  \nit is a blank comand or an  \nadd command');
gettext('Add command:  \njust capture the  \nop1 + op2 value ');
gettext('operand 1');
gettext('Operand 2');
gettext('## HCalc 2-bits accumulator\n\nA 2-bits acumulator is used for adding the 0's and 1's introduced  \nin the Hardware terminal. The result is printed on the console  \nin binary\n');
gettext('12-Ansi-bouncing-ball');
gettext('Sumador de un dos operandos de 8 bits (sin acarreo)');
gettext('**Locate**');
gettext('**Column**');
gettext('**Row**');
gettext('**Hide cursor**');
gettext('01-print-matrix');
gettext('02-Button-state-ANSI');
gettext('03-cowsay-bin');
gettext('04-NOT-truth-table');
gettext('05-ram-2x1-bit-test-term');
gettext('06-Hcalc-acumulator');
gettext('07-Hcalc-terminal');
gettext('08-Hcalc-expresion');
gettext('09-Hcalc-stack');
gettext('10-Hcalc-two-elements-stack');
gettext('11-Hcalc-2bits-acumulator');
gettext('12-Ansi-bouncing-ball');
gettext('getc-bit-01');
gettext('# GETC-BIT: Example 1\n\nReceive a bit of information, coded into the characters '0' and '1'  \nWhen the characters '0' or '1' are received, a tic is emited by rcv  \nand the bit is loaded into the flip-flop\n\nTherefore, using the keys \"1\" and \"0\" we control the state of the  \nLED0\n');
gettext('A bit has arrived.  Store it  \nin the Flip-flop for showing  \nin the LED');
gettext('getc-bit-02');
gettext('# GETC-BIT: Example 2\n\nTwo independent bits are used to control two leds. The first one  \nis controlled by keys '0' and '1' and the second one by keys 's' and  \n'n'\n\nTwo getc-bit modules in cascade are used\n');
gettext('Bit received');
gettext('Bit codified in the  \n'0' and '1' characters');
gettext('Bit codified in the  \n's' and 'n' characters');
gettext('getc-bit-03');
gettext('Baliza luminosa de 2 leds. Parpadean alternativamente a 2Hz cuando se activa');
gettext('Simplified-Heart-Hz-sys-32bits: periodic signal in Hertz. Duty cicle of 50 percent');
gettext('SR1-32bits: Shift  a 32-bit value one bit right. MSB is filled with the input  in');
gettext('Bus32-Split-31-1: Split the 32-bits bus into two buses of 31 and 1 wires');
gettext('Bus32-Join-1-31: Join the two buses into an 32-bits Bus');
gettext('## Test Circuit\n\nIt just blinks the two LEDs,  \nwhen started');
gettext('# GETC-BIT: Example 3\n\nExample of starting a circuit by command line  \nThe circuit to start is a simple one: two blinking LEDs  \nAfter the reset, a message is printed on the console asking  \nif the test circuit should be estarted or no  \n\nIf the user press \"y\" (in lower case) the test circuit is turned on  \nand an ok message is printed on the console\n\nIf the user press \"n\" (in lower case) a message is printed on the  \nconsole and the reception of serial comands is disabled');
gettext('Circuit state:  \n0: Disabled  \n1: Enabled  ');
gettext('Receiver state:  \n0: Disabled  \n1: Enabled');
gettext('Enabling the serial  \nline');
gettext('If \"y\" or \"n\" characters are  \nreceived, the serial line  \nis disabled');
gettext('**Initilialization**');
gettext('Sendd the tic to  \nyes or not depending  \non its value  \nyes: 1  \nno : 0 ');
gettext('After printing the  \ninitial message, the  \nserial line is enabled');
gettext('Initial question');
gettext('NO message');
gettext('YES message');
gettext('**Baliza luminosa**\n\nParpadeo de los LEDs alternativamente a 2Hz, cuando están habilitados ');
gettext('Dividir entre dos el periodo  \n(Multiplicar por 2 la frecuencia)  ');
gettext('getc-char-01');
gettext('Multiplicador de cables. Genera un bus de 4 bits, a patir del bit de entrada');
gettext('# GETC-CHAR: Example 1\n\nThe keys \"1\", \"2\" and \" \" (space) are detected  \nAll the rest are ignored  \nWhen the \"1\" is detected, the LED7 is turn ON\nwhen the \"2\" is detected, the LED7 is turn OFF\nwhen the \" \" is detectaed, the LEDs 0 - 3 are toglled  \n\nThe GETC-CHAR blocks can be chained. Whem a block detect is character, the  \ncorresponding tic signal is removed from the transparent channel and  \nemited to its rcv output');
gettext('Characters different than \"1\", \"2\",  \nor \" \" are received here... but  \nthey are ignored!');
gettext('Tic emitted when the  \n\"2\" char is detected');
gettext('State of the LED 7  \n0: OFF  \n1: ON');
gettext('Tic emitted when the  \n\"1\" char is detected');
gettext('Tic emitted when the   \n\" \"  char is detected');
gettext('LEDs state:  \n0: Group OFF  \n1: Group ON  ');
gettext('Send the 1-bit input  \nto the 4 outputs  ');
gettext('getc-char-02');
gettext('# GETC-CHAR: Example 2\n\nExample of use of the Input and Output console\n\nWhen the 'h' key is pressed, a greeting message is printed  \non the console  \nIf the 'm' key is pressed, the menu is printed again  \nAny other key pressed will print an error message  ');
gettext('Any key diffent than 'h' or 'm' will  \nissue the error cmd');
gettext('**Greetings command**');
gettext('**Menu command**');
gettext('The menu is printed after the reset or  \nwhen the key 'm' is pressed');
gettext('**INPUT CONSOLE**');
gettext('**OUTPUT CONSOLE**');
gettext('getc-char-03');
gettext('# GETC-CHAR: Example 3\n\nTesting a NOT gate\n\nThe key \"1\" set the input to 1   \nThe key \"2\" set the input to 0  \n\nWhenever there is a change in the input, both  \nthe input and output are printed on the console\n');
gettext('**Input**');
gettext('**output**');
gettext('Show the menu  \nafter reset');
gettext('Print the initial  \nstate: input - output');
gettext('Set input to 1');
gettext('Set input to 0');
gettext('## Circuit to TEST');
gettext('Detect a change in the input  \nif so, print input and output');
gettext('Show the output in the LED');
gettext('getc-pritnable-char-01');
gettext('# GETC-PRINTABLE-CHAR: Example 1\n\nOnly the printable characteres received are  \nprinted on the console. The rest are ignored  ');
gettext('getc-bit-01');
gettext('getc-bit-02');
gettext('getc-bit-03');
gettext('getc-char-01');
gettext('getc-char-02');
gettext('getc-char-03');
gettext('getc-pritnable-char-01');
gettext('inputln-bit-test-01-led-on-off');
gettext('# INPUTLN-BIT: Example 1\n\nMini-terminal with two commands: 0 and 1  \nThis commands are used for turning a LED on/off');
gettext('inputln-bitx2-test-01-LEDs');
gettext('## INPUTLN-BITx2-ECHO. Example 1\n\nThe user introduce 2 bits. When the Enter is pressed  \nthese bits are shown in the LEDs\n');
gettext('inputln-char-test-01-LEDs');
gettext('# INPUTLn-PRINTABLE-CHAR-echo Test: Example 2\n\nCheck the inputln printable char echo block  \nThe printable character enter by the user is  \nshown in the LEDs\n');
gettext('Activate the input block');
gettext('Show the received  \nprintable char in  \nthe LEDs');
gettext('inputln-charx2-cmd-echo');
gettext('# INPUTLn-Charx2 Test: Echoing the commands\n\nThe user enters 2-characters commands, in edit mode. When the command is ready,  \nthe Enter key is pressed and the command is stored in a buffer. Then it is  \nprinted on the console\n');
gettext('### Example\n\n```\n>ls\ncmd: ls\n\n>hd\ncmd: hd\n```');
gettext('Enter pressed:  \nPrint the response');
gettext('Dump the command to  \nthe console');
gettext('When the dump tic is received  \nthe buffer is outputed,  \nchar by char');
gettext('The next char is outputed  \nwhen the previous one has  \nalready been printed on the  \nconsole');
gettext('The command is printed  \non the console, char by  \nchar');
gettext('Print one char of the  \ncommand');
gettext('inputln-bit-test-01-led-on-off');
gettext('inputln-bitx2-test-01-LEDs');
gettext('inputln-char-test-01-LEDs');
gettext('inputln-charx2-cmd-echo');
gettext('Input-bit-01');
gettext('# INPUT-BIT: Example 1\n\nExample of the input-bit block. The state of the LED0  \nis set by the user after the initializacion, only once  \nby pressing the '1' or '0' keys  \nThen the OK! message is printed and no more read on the  \nconsole are allowed');
gettext('Start the input machine  \nafter the reset');
gettext('Wait for one bit from  \nthe user');
gettext('Set the LED state with  \nthe value given by user');
gettext('Input is done. Print the  \nOK! message');
gettext('Prit the OK message after  \nthe user has set the state  \nof the LED');
gettext('Abort button. The  \ninput block is stoped');
gettext('Input-bit-02');
gettext('# INPUT-BIT: Example 2\n\nExample of activation of two different input  \nunits. The first one wait for the user to  \nenter \"0\" or \"1\". The second one waits for  \nthe \"y\" or \"n\" symbols  \nWhen finished, the selected LED is blinking or not  \naccording to the user input');
gettext('Print the initial message  \nafter the reset');
gettext('Wait for one bit from  \nthe user: Select LED');
gettext('Select the  \nactive LED');
gettext('LED is selected');
gettext('Initial message');
gettext('Wait for the blinking  \nstate (yes/no)');
gettext('Blinking state');
gettext('Example of the console output:\n\n```\n> Select LED (0/1): \n> Activate blinking? (y/n) \nOK!\n\n```');
gettext('Blink enable/disable');
gettext('Select the LED  \nto blink');
gettext('**ALL starts HERE!!**');
gettext('Second question');
gettext('Input-bit-03');
gettext('Demultiplexor de 1 bit, de 2 a 4');
gettext('**Number**');
gettext('**Number of LEDs**');
gettext('**Count machine**  \nExecute 4 times  \nthe input machine');
gettext('Print messages on the screen  \nThen execute the input machine');
gettext('Wait for the state of the  \nLED n from the console');
gettext('Change the led  \nstate');
gettext('Select the LED');
gettext('LED state, from  \nthe user');
gettext('# INPUT-BIT: Example 3\n\nThere is one input-bit block that is started 4 times by a  \ncount machine. Each user input correspond to the state of one  \nof four LEDs. This is the output in the console:\n\n```\nLED0 state? (0/1) \nLED1 state? (0/1) \nLED2 state? (0/1) \nLED3 state? (0/1) \nOK\n```\n\n');
gettext('**OK message**');
gettext('Input-bit-04');
gettext('# INPUT-BIT: Example 4\n\nTwo chained inputs. The firt bit is used for seting the first  \nLED and the second bit is for the other LED. The two bits  \nare printed on the stdout');
gettext('Start the second  \nmachine ');
gettext('**Print the bit**');
gettext('Input-bit-05');
gettext('# INPUT-BIT: Example 5\n\nAsking the question y/n?. Depending on the answer, one  \nstring or another is printed');
gettext('**START HERE**');
gettext('Repeat the sequence');
gettext('input-printable-char-01');
gettext('# INPUT-PRINTABLE-CHAR Test: Example 1\n\nCheck the input printable char block  \nWhen activated, the printable char is printed on  \nthe console. ');
gettext('input-printable-char-echo-01');
gettext('# INPUT-PRINTABLE-CHAR-echo Test: Example 2\n\nCheck the input printable char echo block  \n');
gettext('Input-bit-01');
gettext('Input-bit-02');
gettext('Input-bit-03');
gettext('Input-bit-04');
gettext('Input-bit-05');
gettext('input-printable-char-01');
gettext('input-printable-char-echo-01');
gettext('input-printable-char-echo-01-orig');
gettext('01-input-bit-button');
gettext('**Read one bit**:  \nWait for the user to  \ntype '1' or '0'');
gettext('Show the received bit  \non the LED');
gettext('Ask for another bit');
gettext('# INPUT-BIT-echo: Example 1\n\nExample of the input-bit-echo block. The state of the LED0  \nis set by the user by pressing the '0' or '1' keys  \nIf valid inputs are received, they are printed (echoed) in the  \nconsole');
gettext('02-input-bit-hterm-01');
gettext('Set the LED according  \nto the command (0/1)');
gettext('Valid command: OK!');
gettext('# INPUT-BIT-echo: Example 2\n\nSimple terminal with only two commands: 0 and 1  \nIt prompts the user to enter the commands. All the  \nkeys are ignored except '1' and '0' that correspond  \nto the valid commands, used to turn the LED on or off\n');
gettext('03-input-bit-hterm-02');
gettext('# Terminal\n\nSmall terminal with two commands:  \n'1' for toggling the LED and  \n'2' for reading the LED's state');
gettext('**Message printing the led state**\n\nString + Bit + Char (new line)');
gettext('Initial \ntic');
gettext('LED state msg');
gettext('01-input-bit-button');
gettext('02-input-bit-hterm-01');
gettext('03-input-bit-hterm-02');
gettext('Alhambra-II');
gettext('Blackice-I');
gettext('Icestick');
gettext('Lattice-Breakout-board');
gettext('Nandland-Go-Board');
gettext('TinyFPGA-BX');
gettext('iCEBreaker');
gettext('Hello-world');
gettext('## Hello World\n\nIt prints the string \"Hello World\"  \nevery second\n\n```\nHello World!\nHello World!\nHello World!\n...\n```');
gettext('Alhambra II system clock');
gettext('Hello-world');
gettext('Hello-world');
gettext('Simplified-Heart-tic-sec-sys-32bits: Nominal periodic signal in seconds');
gettext('Unit-s-32bits: seconds to cycles converter');
gettext('BlackIce I system clock:  \n100MHz');
gettext('UART-TX connection');
gettext('T Flip-Flop');
gettext('## Hello World\n\nIt prints the string \"Hello World\"  \nrepeteadly \n\n```\nHello World!\nHello World!\nHello World!\n...\n```');
gettext('Hello-world');
gettext('Hello-world');
gettext('Icestick system clock');
gettext('Hello-world');
gettext('Hello-world');
gettext('iCE40 Breakout board  \nsystem clock');
gettext('Hello-world');
gettext('Hello-world');
gettext('Nandland Go-board  \nsystem clock: 25Mhz');
gettext('Hello-world');
gettext('Hello-world');
gettext('TinyFPGA BX System clock');
gettext('Hello-world');
gettext('Hello-world');
gettext('iCEBreaker system clock');
gettext('Hello-world');
gettext('Print-int');
gettext('Test');
gettext('Print-01-two-buttons');
gettext('# PRINT: Example 1\n\nExample of the PRINT block:  printing a  \nconstant string\n\nTwo differente messages are printed, according  \nto the button pressed\n\n* Button 1 ---> Message 1  \n* Button 2 ---> Message 2');
gettext('**Print message 1**');
gettext('**Print message 2**');
gettext('**Print-ASC** block: The message should be in ASCII in a memory block\n\nAscii codes of a string can be easily obtained by running the following  \nline in python3\n\n\n```pythonn\nprint(\" \".join([\"{:02X}\".format(ord(i)) for i in \"Message\"]) + \" 00\")\n```');
gettext('Print-02-two-buttons-ASCII-art');
gettext('# PRINT: Example 2\n\nSame circuit than the example 1 but the messages has been  \nchanged for big numbers in ASCII art:\n\n* Message for the button SW1:\n\n```\n  _ \n / |\n | |\n | |\n |_|\n```\n\n* Message for the button SW2:\n\n```\n  ____  \n |___ \\ \n   __) |\n  / __/ \n |_____|\n```\n\n');
gettext('Print-03-menu');
gettext('# PRINT: Example 3\n\nAn initial message and a menu are printed initially,  \nafter the reset\n\nWhen the button sw1 is pressed the led is toggle and the  \nOK message is printed on the console\n\nWhen the button sw2 is pressed, the led stated is printed  \non the console');
gettext('This message is printed just  \none time, after the reset');
gettext('**Print the Menu**');
gettext('** Button 2 pressed**');
gettext('** Button 1 pressed**');
gettext('Print-04-str-two-buttons');
gettext('# PRINT: Example 4\n\nExample of the block print-str: printing the string  \npassed as a parameter\n\nDepending on the button pressed, 1 or 2, the messages  \n\"B1 \" or \"B2 \" are printed on the console\n');
gettext('Print-base4-bin-01-counter');
gettext('# PRINT-base4-bin: Example 1: Counter\n\nPrinting the numbers from 0 to 3 in binary');
gettext('Show the number  \nin the LEDs');
gettext('Print-base4-bin-02-two-buttons');
gettext('# PRINT-base4-bin: Example 2: Two buttons\n\nPrint the state of the two buttons as a 2-dibgit binary number  \nIt is printed on every button's change');
gettext('Number to print  \n(in binary)');
gettext('There is a change on  \nsome button');
gettext('Print in  \nBinary');
gettext('Print-hex-01-Button-counter');
gettext('Counter-x08: 8-bits counter');
gettext('Inc1-8bit: Increment a 8-bits number by one');
gettext('AdderK-8bit: Adder of 8-bit operand and 8-bit constant');
gettext('Print-hex-12-01-Button-table');
gettext('Circuito combinacional de 3 entradas y 12 salidas');
gettext('Print-hex-16-01-Button-table');
gettext('Circuito combinacional de 3 entradas y 16 salidas');
gettext('Print-uint12-test-01');
gettext('Máquina de contar, de 12 bits');
gettext('Valor genérico constante (menos 1), de 12 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Comparador de dos operandos de 12 bits');
gettext('12-Reg-rst: 12 bits Register with reset. Verilog implementation');
gettext('Print-uint16-test-01');
gettext('Máquina de contar, de 16 bits');
gettext('Comparador de dos operandos de 16 bits');
gettext('Valor genérico constante (menos 1), de 16 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('16-Reg-rst: 16 bits Register with reset. Verilog implementation');
gettext('Print-uint4-01-button-counter');
gettext('Counter-x04: 4-bits counter');
gettext('Inc1-4bit: Increment a 4-bits number by one');
gettext('AdderK-4bit: Adder of 4-bit operand and 4-bit constant');
gettext('Print-uint4-02-count');
gettext('Print-uint8-test-01');
gettext('Máquina de contar, de 8 bits');
gettext('print-int4-test-01');
gettext('Start counting from -8 up to 7');
gettext('Print a 4-bits  \nsigned integer');
gettext('print-int12-test-01');
gettext('Start counting from (-2048 up to 2047)');
gettext('Print a 12-bits  \nsigned integer');
gettext('print-int16-test-01');
gettext('Start counting from (-32768 up to 32767)');
gettext('Print a 16-bits  \nsigned integer');
gettext('print-int8-test-01');
gettext('Start counting from -128 up to 127');
gettext('Print a 8-bits  \nsigned integer');
gettext('print-int12-test-01');
gettext('print-int16-test-01');
gettext('print-int8-test-01');
gettext('asc');
gettext('str');
gettext('Test-print-asc-02');
gettext('## Test Print-asc-02 \n\nTesting the Print-asc-2 block  \nWhen the button is pressed the charachter  \n'X' is sent');
gettext('Test-print-asc-04');
gettext('## Test Print-asc-04 \n\nTesting the Print-asc-4 block  \nWhen the button is pressed the string    \n\"OK\\n\" is printed!');
gettext('Test-print-asc-08');
gettext('## Test Print-asc-08 \n\nTesting the Print-asc-8 block  \nWhen the button is pressed the  \nmessage is printed');
gettext('Test-print-asc-128');
gettext('## Test Print-asc-128\n\nTesting the Print-asc-128 block  \nWhen the button is pressed the  \nmessage is printed');
gettext('Test-print-asc-16');
gettext('## Test Print-asc-16 \n\nTesting the Print-asc-16 block  \nWhen the button is pressed the  \nmessage is printed');
gettext('Test-print-asc-256');
gettext('## Test Print-asc-256\n\nTesting the Print-asc-256 block  \nWhen the button is pressed the  \nmessage is printed');
gettext('Test-print-asc-32');
gettext('## Test Print-asc-32 \n\nTesting the Print-asc-32 block  \nWhen the button is pressed the  \nmessage is printed');
gettext('Test-print-asc-64');
gettext('## Test Print-asc-64 \n\nTesting the Print-asc-64 block  \nWhen the button is pressed the  \nmessage is printed');
gettext('Test-print-asc-02');
gettext('Test-print-asc-04');
gettext('Test-print-asc-08');
gettext('Test-print-asc-128');
gettext('Test-print-asc-16');
gettext('Test-print-asc-256');
gettext('Test-print-asc-32');
gettext('Test-print-asc-64');
gettext('Test-print-str-02');
gettext('## Test Print-str-02 \n\nTesting the Print-asc-2 block  \nWhen the button is pressed the charachter  \n'X' is sent');
gettext('Test-print-str-04');
gettext('## Test Print-str-04 \n\nTesting the Print-str-4 block  \nWhen the button is press, the \"ok\"  \nstring is printed (it is also printed  \nafter the reset)');
gettext('Test-print-str-08');
gettext('## Test Print-str-08\n\nTesting the Print-str-8 block  \nWhen the button is press the  \nstring is printed (it is also printed  \nafter the reset)');
gettext('Test-print-str-128');
gettext('## Test Print-str-128\n\nTesting the Print-str-128 block  \nWhen the button is press the  \nstring is printed (it is also printed  \nafter the reset)');
gettext('Test-print-str-16');
gettext('## Test Print-str-16\n\nTesting the Print-str-16 block  \nWhen the button is press the  \nstring is printed (it is also printed  \nafter the reset)');
gettext('Test-print-str-256');
gettext('## Test Print-str-256\n\nTesting the Print-str-256 block  \nWhen the button is press the  \nstring is printed (it is also printed  \nafter the reset)');
gettext('Test-print-str-32');
gettext('## Test Print-str-32\n\nTesting the Print-str-32 block  \nWhen the button is press the  \nstring is printed (it is also printed  \nafter the reset)');
gettext('Test-print-str-64');
gettext('## Test Print-str-64\n\nTesting the Print-str-64 block  \nWhen the button is press the  \nstring is printed (it is also printed  \nafter the reset)');
gettext('Test-print-str-02');
gettext('Test-print-str-04');
gettext('Test-print-str-08');
gettext('Test-print-str-128');
gettext('Test-print-str-16');
gettext('Test-print-str-256');
gettext('Test-print-str-32');
gettext('Test-print-str-64');
gettext('Print-01-two-buttons');
gettext('Print-02-two-buttons-ASCII-art');
gettext('Print-03-menu');
gettext('Print-04-str-two-buttons');
gettext('Print-base4-bin-01-counter');
gettext('Print-base4-bin-02-two-buttons');
gettext('Print-hex-01-Button-counter');
gettext('Print-hex-12-01-Button-table');
gettext('Print-hex-16-01-Button-table');
gettext('Print-uint12-test-01');
gettext('Print-uint16-test-01');
gettext('Print-uint4-01-button-counter');
gettext('Print-uint4-02-count');
gettext('Print-uint8-test-01');
gettext('print-int4-test-01');
gettext('test');
gettext('PrintLn-BitVar-01');
gettext('## PrintLN-BitVar-01\n\nThe state of the SW1 button is printed on the  \nconsole. The variable a is assigned. In the console you will  \nsee the value of the a varible:  \n```\na1\na0\n...\n```\n\n');
gettext('PrintLn-base4-01-counter');
gettext('# PRINTLN-base4: Example 1\n\nPrinting the numbers from 0 to 3');
gettext('PrintLn-bit-01-button');
gettext('# PRINTLN-bit: Example 1\n\nExample using the PrintLN-bit block\nPrinting the state of the Button 2 when the  \nbutton 1 is pressed');
gettext('Println-ok-01-button');
gettext('PrintLn-BitVar-01');
gettext('PrintLn-base4-01-counter');
gettext('PrintLn-bit-01-button');
gettext('Println-ok-01-button');
gettext('Putc-Base-4');
gettext('Putc-bit');
gettext('Putc-char');
gettext('Putc-hex');
gettext('putc-base4-01');
gettext('# PUTC-BASE4-stdout: Example 1\n\nPrinting the 0,1,2 and 3 numbers');
gettext('putc-base4-01');
gettext('putc-bit-01');
gettext('Transmit the bit as  \na character ('1' or '0')');
gettext('Bit to transmit  \nIs changed every tic: 0,1,0...');
gettext('Transmit the current bit');
gettext('# PUTC-BIT-stdout: Example 1\n\nSending alternated bits: 0,1,0,1,0,1...  \nRate of Speed: 2 Bits per seccond (2 Hz)');
gettext('putc-bit-02');
gettext('Transmit the button state');
gettext('# PUTC-BIT-stdout: Example 2\n\nThe button 1 is sampled at 10Hz and its state is transmitted');
gettext('State of the button:  \n0: Not pressed  \n1: Pressed');
gettext('putc-bit-03-button-changed');
gettext('Transmit one bit as a characters');
gettext('# PUTC-BIT-stdout: Example 3\n\nThe button state is transmited whenever there is a changed  \non it: either pressed or released');
gettext('Button state:  \n0: Not presssed  \n1: Pressed');
gettext('The button state  \nhas changed');
gettext('Transmit the  \nbutton state');
gettext('The state is transmitted  \ninitially and whenever  \nthere is a change  \nin the button ');
gettext('putc-bit-04-two-buttons');
gettext('# PUTC-BIT-stdout: Example 4\n\nWhen the button 1 is pressed, a 0 is sent  \nWhen the button 2 is pressed, a 1 is sent  ');
gettext('Send '0' when the  \nbutton 1 is pressed');
gettext('Send '1' when the  \nbutton 2 is pressed');
gettext('putc-bit-05-two-buttons2');
gettext('# PUTC-BIT-stdout: Example 5\n\nThe state of both buttons is printed on the console   \n4 times per second  \nThe bits are sent in pairs. When the tic from the heart  \nreaches the first putc-bit module, it sends the button  \n1 state to the stdout bus (it passes through the second  \nputc-bit module as it is OFF (transparent mode))  \n\nWhen it finish, a tic is emited on the done signal that  \nis connected to the txmit input of the second module, allowing  \nit to send the state of the button 2 to the serial port  \n\n');
gettext('Button 2 state');
gettext('Button 1 state');
gettext('When module 1 is  \nfinished, module 2  \nis started');
gettext('**Module 1**');
gettext('**Module 2**');
gettext('putc-bit-06-AND-test');
gettext('# PUTC-BIT-STDOUT: Example 6\n\nShow the inputs (A,B) and output (C) of the AND gate on the console  \nThe Serial output done is connected to next label and should be connected to  \nthe next input of the three Putc-bit blocks\n\nThere are three putc-bit blocks: The first one is for printing the A signal,  \nthe second for the B signal and the third for the C signal\n\nThe module 1 is activated 4 times per second (4Hz). When it is done, the module 2  \nis activated, and then the third ');
gettext('**Module 3**');
gettext('Sample the main circuit  \n4 times per second');
gettext('**Main circuit**: an AND gate controlled by  \ntwo buttons');
gettext('This module sends the \"F\" and  \n\"T\" character instead of 0/1');
gettext('putc-bit-07-AND-test2');
gettext('# PUTC-BIT-STDOUT: Example 7\n\nExample of use of the **STDOUT BUS**  \nIt is the same than example 6, but the signals A,B and C  \nare printed on the console only when there is a change in  \nA or B\n');
gettext('**Main circuit**  ');
gettext('Changes in A and B signals');
gettext('Print the initial state');
gettext('putc-bit-01');
gettext('putc-bit-02');
gettext('putc-bit-03-button-changed');
gettext('putc-bit-04-two-buttons');
gettext('putc-bit-05-two-buttons2');
gettext('putc-bit-06-AND-test');
gettext('putc-bit-07-AND-test2');
gettext('putc-char-01');
gettext('8bits ASCII Letter A');
gettext('# PUTC-CHAR: Example 1\n\nExample of use of the putc-char block  \nThe 'A' character is sent every second\n');
gettext('putc-char-02');
gettext('Simplified-Heart-tic-ms-sys-32bits: Nominal periodic signal in mili seconds');
gettext('# PUTC-CHAR: Example 2\n\nExample of chaining the putc-char block with the  \nputc-bit block. The state of the button 1 is  \nprinted on the console every 100ms\n\nFirst the state is printed, followed by a New line\n');
gettext('**Module 2**  \nNew line  ');
gettext('**Module 1**  \nPrinting the button  \nstate');
gettext('putc-char-03');
gettext('# PUTC-CHAR: Example 3\n\nMonitoring a NOT gate: The state of the input and  \noutput are sent throug the serial port every 100ms');
gettext('**Module 3**  ');
gettext('**Module 1**  ');
gettext('**Module 2**  ');
gettext('Print the output  \nas a T or F character');
gettext('Print the Input  \nas '0' or '1' characters');
gettext('Print a new line \n(\\n)');
gettext('Every 100ms the module 1 is started  \nfor printing the input (A). When  \nit is finished, the module 2 is  \nstarted for printing the output (B)  \nand finally the module for printing  \nthe new line character  ');
gettext('putc-char-04');
gettext('Código ASCII del carácter LF');
gettext('# PUTC-CHAR: Example 4\n\nMonitoring a NOT gate: The state of the input and  \noutput are sent throug the serial port whenever  \nthere is a change in its input (also after the reset)  ');
gettext('Where there is a change in the input  \nthe module 1 is started for printing  \nthe input (A). When it is finished,  \nthe module 2 is started for printing  \nthe output (B) and finally the module  \nfor printing the new line character  ');
gettext('There is change in the  \nbutton state  ');
gettext('Initial tic after  \nreset');
gettext('Print the signals  \nif there is a changed  \nin the input or after  \na reset');
gettext('Show the current  \noutput in the LED');
gettext('putc-char-05');
gettext('# PUTC-CHAR: Example 5\n\nExample of use of two putc-char blocks in a chain  \nThe 'A' character is sent every second  \nWhen the button is pressed, the character '*'  \nis sent\n');
gettext('putc-char-06');
gettext('# PUTC-CHAR: Example 6\n\nExample of chaining the putc-char block with the  \nputc-bit block. The state of the button 1 is  \nprinted on the console every 100ms\n\nFirst the state is printed, followed by a New line\n\n');
gettext('**Print(\"\\n\")**');
gettext('**Print the button**  \n**state as a character**  ');
gettext('putc-char-07');
gettext('Código ASCII del carácter J');
gettext('# PUTC-CHAR: Example 7\n\nExample of chaining two putc-char blocks  \nWhen idle, the Character * is printed on the  \nconsole every 2 seconds. If the SW1 is pressed,  \nthe A character is printed. If the SW is pressed,  \nand J character is printed followed by an 'A'\n');
gettext('The char * is printed on the  \nconsole every 2 seconds');
gettext('When the SW2 button is pressed  \nthe J Char is sent, and when it is  \ndone, the A is sent by module 2');
gettext('If the SW1 button is pressed, an  \nA character is sent');
gettext('The A character is also sent  \nwhen the module 1 it is done');
gettext('Create the stdout bus by  \nadding data and tic to rdy');
gettext('putc-char-08');
gettext('# PUTC-CHAR: Example 8\n\nExample of monitoring a NOT Gate. It has only one input (A)  \nand one output (S). This both signals are printed on the  \nconsole every 100ms\n\nExample of what is printed on the console:\n\n```\nA0S1\nA0S1\nA1S0\nA0S1\n...\n```');
gettext('**Print bit S**');
gettext('**Print(\"S\")**');
gettext('**Print bit A**');
gettext('**Print(\"A\")**');
gettext('**Module 4**');
gettext('**Module 5**');
gettext('The module 1 is activated every 100ms  \nAs all the modules are chained, when the  \ni module is done, the i+1 module is started   \n');
gettext('### Circuit to monitorize');
gettext('putc-char-01');
gettext('putc-char-02');
gettext('putc-char-03');
gettext('putc-char-04');
gettext('putc-char-05');
gettext('putc-char-06');
gettext('putc-char-07');
gettext('putc-char-08');
gettext('01-putc-hex-test1');
gettext('# Putc-hex-test-1:\n\nPrint a hexadecimal char when the button  \nSW1 is pressed');
gettext('01-putc-hex-test1');
gettext('Syntax-char-toggle-led');
gettext('### Example\n\n```\n>t\n1\nOK!\n>t\n0\nOK!\n>hd\nUnknown command\n>\n```');
gettext('## Unkwnon command output');
gettext('Syntax-char-toggle-led');
gettext('stdout-LEDx8-test-01');
gettext('# STDOUT-LEDx8: Example 1\n\nTesting the LEDx8 stdout device  \n\nSend the bits 1 and 0 to the STDOUT bus, where the  \n8-device LEDs is connected');
gettext('Bit 1');
gettext('Bit 2');
gettext('**STDOUT** BUS  ');
gettext('**Print Bit 1**');
gettext('**Print Bit 0**');
gettext('stdout-LEDx8-test-02');
gettext('# STDOUT-LEDx8: Example 2\n\nTesting two output devices connected to the  \nSTDOUT BUS\n\nThe bits 0 and 1 are sent when the buttons 0 and 1 are  \npressed respectively.  They are printed on both devices:  \nThe serial console and the LEDs');
gettext('**OUTPUT DEVICE 1:** LEDS  ');
gettext('**OUTPUT DEVICE 2:** SERIAL  ');
gettext('**IMPORTANT**  \n\nONLY one rdy signal should be inserted  \non the STDOUT BUS: It should be the signal  \nfrom the slowest device (in this case  \nthe serial console is slower)\n');
gettext('stdout-LEDx8-test-03');
gettext('# STDOUT-LEDx8: Example 3\n\nThe state of the buttons 1 and 2 is printed on two consoles  \nat the same time: the LEDs and the Serial port  \nThey are only printed whenever there is a change in any  \nof the buttons');
gettext('**Button 1 state**');
gettext('**Button 2 state**');
gettext('Move the cursor 2  \ncharacters back');
gettext('stdout-LEDx8-test-04');
gettext('**STDIN BUS**  ');
gettext('**STDOUT BUS**  ');
gettext('# STDOUT-LEDx8: Example 4\n\nCombination of the output LED8 device with an input device  \nThe keyboard is used for introducing 1s and 0s  \nThe are printed on the current cursor position in the LEDs  \nIf the backspace key is pressed, the cursor is moved back one  \ncharacter.  When ENTER is pressed a new line can be entered\n');
gettext('The same output is shown in  \ntwo group of LEDs');
gettext('Board LEDs');
gettext('External LEDs');
gettext('stdout-LEDx8-test-05');
gettext('# STDOUT-LEDx8: Example 5\n\nExample of combining 4 i/o devices: two inputs and two outputs\n\nTwo input devices are combined into one STDIN:  \nThe serial input and the keyboard  \nAll the characters inputed are written on both  \noutput devices: serial and LEDs\n');
gettext('stdout-LEDx8-test-01');
gettext('stdout-LEDx8-test-02');
gettext('stdout-LEDx8-test-03');
gettext('stdout-LEDx8-test-04');
gettext('stdout-LEDx8-test-05');
